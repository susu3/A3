MODBUS Messaging on TCP/IP Implementation Guide V1.0b Modbus Organization  
October 24, 2006 http://www.Modbus.org 1/46MODBUS MESSAGING ON TCP/IP  IMPLEMENTATION GUIDE 
V1.0b 
CONTENTS 
1 INTRODUCT ION ........................................................................................................... 2  
1.1 OBJECTIVES ....................................................................................................... 2  
1.2 CLIENT / SERVER  MODEL................................................................................... 2  
1.3 REFERENCE DO CUMENTS ................................................................................. 3  
2 ABBREVIATIO NS .......................................................................................................... 3  
3 CONTEXT ..................................................................................................................... 3  
3.1 PROTOCOL DES CRIPTION ................................................................................. 3  
3.1.1  General communication  architec ture ......................................................... 3  
3.1.2  MODBUS On TCP/IP App lication Data  Unit ............................................... 4  
3.1.3  MBAP Header de scripti on ......................................................................... 5  
3.2 MODBUS FUNCTIONS CO DES DESCRI PTION .................................................... 6  
4 FUNCTIONAL DES CRIPTION........................................................................................ 7  
4.1 MODBUS COMPONENT A RCHITECTURE MODEL............................................... 7  
4.2 TCP CONNECTION MANAGEME NT ....................................................................10  
4.2.1  Connections managem ent Modul e............................................................10  
4.2.2  Impact of Operating Modes on the TCP Co nnecti on..................................13  
4.2.3  Access Contro l Modu le ............................................................................14  
4.3 USE of TCP/IP  STACK ........................................................................................14  
4.3.1  Use of BSD Socke t interf ace ....................................................................15  
4.3.2  TCP  layer param eterizat ion.....................................................................18  
4.3.3  IP layer paramet erizatio n .........................................................................19  
4.4 COMMUNICATION APPL ICATION LAYER...........................................................20  
4.4.1  MODBUS C lient .......................................................................................20  
4.4.2  MODBUS Se rver......................................................................................26  
5 IMPLEMENTATION GUIDELIN E ...................................................................................32  
5.1 OBJECT MODEL DIAGRAM ................................................................................32  
5.1.1  TCP managemen t pack age ......................................................................33  
5.1.2  Configuration la yer pack age.....................................................................35  
5.1.3  Communication la yer pack age..................................................................36  
5.1.4  Interface cl asses......................................................................................37  
5.2 IMPLEMENTATION CLASS DIAGRAM.................................................................37  
5.3 SEQUENCE DI AGRAMS......................................................................................39  
5.4 CLASSES AND METHODS DESCRIPT ION ..........................................................42  
5.4.1  MODBUS Server  Class ............................................................................42  
5.4.2  MODBUS Client Class..............................................................................43  
5.4.3  Interface Cl asses.....................................................................................44  
5.4.4  Connexion Management  class..................................................................45  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
1 INTRODUCTION 
1.1 OBJECTIVES 
The objective of this document is to pr esent the MODBUS messaging service over 
TCP/IP , in order to provide reference info rmation that helps software developers to 
implement this service. The encoding of the MODBUS function codes is not described 
in this document, for this information plea se read the MODBUS Application Protocol 
Specification [1].   
This document gives accurate and comprehensive description of a MODBUS messaging 
service implementation. Its purpose is to facilitate the interoperability between the devices using the MODBUS messaging service. 
This docu ment c
omprises mainly three parts:  
•An overview of the MODBUS over TCP/IP protocol
•A functional description of a MODBUS client, server and gateway
implementation.
•An implementation guideline that prop oses the object model of an MODBUS
implementation example.
1.2 CLIENT / SERVER MODEL 
The MODBUS messaging service provides a Client/Server communication between 
devices connected on an Ethernet TCP/IP network. 
This client / server model is based on four type of messages:  
•MODBUS Request,
•MODBUS Confirmation,
•MODBUS Indication,
•MODBUS Response
MODBUS Client MODBUS Serve rRequest Indication
Response Confirmation
A MODBUS Request  is the message sent on the network by the Client to initiate a 
transaction, 
A MODBUS Indication is the Request message received on the Server side, A MODBUS Response is the Response message sent by the Server, 
A MODBUS Confirmation is the Response Message received on the Client side 
The MODBUS messaging services (Client / Server Model) are used for real time 
information exchange: 
•between two device applications,
•between device application and other device,
•between HMI/SCADA applications and devices,
•between a PC and a device program providing on line services.
October 24, 2006 http://www.Modbus.org 2/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 3/46-  
1.3 REFERENCE DOCUMENTS 
This section gives a list of documents that ar e interest ing to read before this  one: 
[1] MODBUS Application Prot ocol Specification V1.1a.
[2] RFC 1122 Requirements for Internet Hosts -- Communication Layers
2 ABBREVIATIONS 
ADU Application Data Unit 
IETF  Internet Engineering Task Force 
IP Internet 
Protocol  
MAC  Medium Access Control  
MB MODBUS  
MBAP  MODBUS Application Protocol 
PDU  Protocol Data Unit 
PLC  Programmable Logic Controller  
TCP  Transport Control Protocol 
BSD   Berkeley Software Distribution 
MSL Maximum Segment Lifetime  
3 CONTEXT 
3.1 PROTOCOL DESCRIPTION 
3.1.1 General communication architecture 
A communicating system over MODBUS TCP/IP may include different types of device: 
•A MODBUS TCP/IP Client and Server dev ices connected to a TCP/IP network
•The Interconnection devices like bridge, router or gateway for interconnection
between the TCP/IP network and a serial line sub-network which permit
connections of MODBUS Serial line Client and Server end devices.Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
MODBU
S Client 
TCP/IP 
MODBU
S Server 
TCP/IP MODBU
S Server 
TCP/IP MODBUS 
Server 
Serial Line MODBUS 
Server 
Serial Line MODBUS 
Client 
Serial Line 
MODBU
S Client 
TCP/IP 
MODBUS Client 
TCP/IP
Server TCP/IP
gatewa y
MODBUS Serial 
Figure 1: MODBUS TCP/IP communication architecture 
The MODBUS protocol defines a simple Protocol Data Unit  (PDU) independent of the 
underlying communication layers. The mapping of MODBUS protocol on specific buses 
or networks can introduce some additional fields on the Application Data Unit  (ADU).  
Additional address Function code Data Error checkADU
PDU
Figure 2: General MODBUS frame 
The client that initiates a MODBUS transaction builds the MODBUS Application Data 
Unit. The function code indicates to the se rver which kind of action to perform. 
3.1.2 MODBUS On TCP/IP Application Data Unit 
This section describes the encapsulation of a MODBUS request or response when it is carried on a MODBUS TCP/IP network.  
Function code Data MBAP Header
PDUMODBUS TCP/IP ADU
Figure 3: MODBUS request/response over TCP/IP 
A dedicated header is used on TCP/IP to ident ify the MODBUS Application Data Unit. It 
is called the MBAP header (MODBUS A pplication Protocol header).  
October 24, 2006 http://www.Modbus.org 4/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 5/46This header provides some differences comp ared to the MODBUS RTU application data 
unit used on serial line:  
The MODBUS ‘slave address’ field usua lly used on MODBUS Serial Line is
replaced by a s
ingle byte ‘Unit Identifier’ within the MBAP Header. The
‘Unit Identifier’ is used to communicate via devices such as bridges,
routers and gateways that use a single IP address to support multiple
independent MODBUS end units.
All MODBUS requests and responses are designed in such a way that therecipient can verify that a message is finished. For function codes wherethe MODBUS PDU has a fixed length, the func
tion code alone is sufficient.
For function codes carrying a variable amount of data in the request orresponse, the data field includes a byte count.
When MODBUS is carried over TCP, additional length information is
carried in 
the MBAP header to allow the recipient to recognize message
boundaries even if the message has been split into multiple packets fortransmission. The existence of explicit and implicit length rules, and use of
a CRC-32 error check code (on Ethernet) results in an infinitesimal chanceof undetected corruption to a request or response message.
3.1.3 MBAP Header description 
The MBAP Header contains the following fields: 
Fields  Length Description - Client  Server  
Transaction 
Identifier  2 Bytes Identification of a 
MODBUS Request / Response transaction. Initialized by the client  Recopied by the server from the receiv ed 
request  
Protocol Identifier 2 Bytes  0 = MODBUS protocol Initialized by the client Recopied by the server from the received 
request 
Length 2 Bytes Number of following 
bytes  Initialized by the client ( request) Initialized by the server ( 
Response)  
Unit Identifier 1 Byte Identification of a 
remote slave connected on a serial line or on other buses. Initialized by the client Recopied by the server from the received 
request 
The header is 7 bytes long: 
•Transaction Identifier   - It is used for transaction pairing, the MODBUS server copies
in the response the transaction identifier of the request.
•Protocol Identifier   – It is  used for intra-system mu ltiplexing. The MODBUS protocol
is identified by the value 0.
•Length  - The length field is a byte count of the following fields, including the Unit
Identifier and data fields.Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 6/46•Unit Identifier  – This field is used for intra-system  routing purpose.  It is typically
used to communicate to a MODBUS+ or a MODBUS serial line slave through a
gateway between an Ethernet TCP-IP network and a MODBUS serial line. This field is
set by the MODBUS Client in the request and must be returned with the same value in
the response by the server.
All MODBUS/TCP ADU are sent via TCP to registered port 502.  
Rem
ark : the different fields are encoded in Big-endian. 
3.2 MODBUS FUNCTIONS CODES DESCRIPTION 
Standard function codes used on MODBUS applic ation layer protocol are described in 
details in the MODBUS Applicat ion Protocol Specification [1]. Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
4 FUNCTIONAL DESCRIPTION 
The MODBUS Component Architecture presented here is a general model including 
both MODBUS Client and Server Components and usable on any device.  
Some devices may only provide the server or the client component. In the first part of this section a brief overview of the MODBUS messaging service 
component architecture is given, follo wed by a description of each component 
presented in the architectural model. 
4.1 
MODBUS COMPONENT ARCHITECTURE MODEL 
USER
APPLICATION
Communication
Application
Layer
Modbus Client Modbus ServerModbus Client
Interface
TCP
Management
Connection
 ManagementAccess Ctl
TCP/IP StackStack
parmeterizationModbus Backend
InterfaceRessource Management
&
Flow Control
Figure 4: MODBUS Messaging Service Conceptual Architecture 
•Communication Application Layer
A MODBUS device may provide a client and/or a server MODBUS interface. 
A MODBUS backend interface can be provided allowing indirectly the access to user 
application objects.  
Four areas can compose this 
interface: input discrete, output discrete (coils), input 
registers and output registers. A pre-mapping  between this interface and the 
user 
application data has to be done (local issue). 
October 24, 2006 http://www.Modbus.org 7/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Primary tables Object type Type of Comments 
 Discretes Input Single bit Read-Only This type of data can be provided by an I/O system. 
Coils Single bit Read-Write This type of data can be alterable by an application 
program. 
Input Registers 16-bit word Read-Only This type of data can be provided by an I/O system 
Holding Registers 16-bit word Read-Write This type of data can be alterable by an application 
program. 
Input DiscreteMODBUS accessDevice application memory
MODBUS SERVER DEVICEMODBUS Request Coils
Input Registers
Output Registers
Figure 5 MODBUS Data Model with 
separate blocks Device application memory
MODBUS SERVER DEVICEMODBUS RequestInput DiscreteMODBUS access
Coils
Input Registers
Output RegistersR
W
R
W
Figure 6 MODBUS Data Model with only 
1 block  
¾MODBUS Client
The MODBUS Client allows the user applic ation to explicitly control information 
exchange with a remote device. The 
MODBUS  Client builds a MODBUS request from 
parameter contained in a demand sent by the user application to the MODBUS Client 
Interface.  
The MODBUS Client uses a MODBUS transac tion whose management includes waiting 
for and processing of a MODBUS confirmation.  
¾MODBUS Client Interface
The MODBUS Client Interface provides an interface enabling the user application to 
build the requests for various MODBUS 
services including access to MODBUS 
application objects. The MODBUS Client in terface (API) is not part of  this 
Specification, although an example is described in the implementation model. 
¾MODBUS Server
On reception of a MODBUS request this modu le activates a local action to read, to 
write 
or to achieve some other actions. The pr ocessing of these actions is done totally 
transparently for the application programmer. The main MODBUS server functions are 
to wait for a MODBUS request on 502 TCP port, to treat this request and then to build a 
MODBUS response depending on device context. 
¾MODBUS  Backend Interface
The MODBUS Backend Interface is an interfac e from the MODBUS Server to the user 
application in which the application objects are defined. 
October 24, 2006 http://www.Modbus.org 8/46Informative Note: The Backend Interface is  not defined in this Specification Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 9/46•TCP Management layer
Informative Note: The TCP/IP discussion in th is Specification is based in part upon 
reference 
[2] RFC 1122 to assist the user in implementing the MODBUS Application 
Protocol Specification [1] over TCP/IP. 
One of the main functions of the messaging service is to manage communication 
establishment and ending and to manage  the data flow on established 
TCP 
connections. 
¾Connection Management
A communication between a client and server MODBUS Module requires the use of a 
TCP connection management module. It is in charge to manage globally messaging TCP connections.  
Two possibilities are proposed for the connection management. Either the user application itself manages TCP connections or the connection management is totally 
done by this module and therefore it is transparent for the user application. The last solution implies less flexibility.   
The listening TCP port 502 is reserved for MODBUS communications. It is 
mandatory to listen by default on that port. Ho wever, some markets or applications 
might require that another port is dedicated to MODBUS over TCP.  For that reason, it 
is highly recommended that the clients and the servers give the possibility to the user 
to parameterize the MODBUS over TCP port number. It is important to note that 
even if another TCP server port is configured for MODBUS service in certain 
applications, TCP server port 502 must still be available in addition to any application specific ports.   
¾Access Control Module
In certain critical contexts, accessibility to in ternal data of devices must be forbidden for 
undesirable hosts. That’s why a security mode  is needed and security process may be 
implemented if required. 
•TCP/IP Stack lay er
The TCP/IP stack can be parameterized in order to adapt the data flow control, the 
address management and the connection manageme nt to different constraints specific 
to a product or to a system. Generally the BSD 
socket interface is used to manage the 
TCP connections. 
 Resource management and Data flow control
In order to equilibrate inbound and outbound messaging data flow between theMODBUS client and the server, data flow cont rol mechanism is provided in all layers
of MODBUS messaging stack.
The resource management and flow control module  is first based on TCP internal flow
control added with some data flow control in the data link 
layer and also in the user
application level.Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 10/464.2 TCP CONNECTION MANAGEMENT 
4.2.1 Connections management Module  4.2.1.1 General description 
A MODBUS communication requires the establishment of a TCP connection between a 
Client and a Server.  
The establishment of the connection can be activated either explicitly by the User 
Application module or automatically by the TCP connection management module.  
In the first case an application-programming interface has to be provided in the user 
application module to manage completely the connection. 
This solution provides 
flexibility for the application programmer but it  requires a good expertise on TCP/IP 
mechanism. 
In the second case the TCP connection management is completely hidden to the user 
application that only sends and receives MODBUS messages. The TCP connection 
management module is in charge to estab lish a new TCP connection when it is 
required.  
The definition of the number of TCP client and server connections is not on the scope of 
this document (value n in this document).  Depending on the device 
capacities the 
number of TCP connections can be different. 
Implementation Rules : 
1) Without explicit user requirement, it is recommended to implement the automatic TCP
connection management
2) It is recommended to keep the TCP connection opened with a remote device and not
to open and close  it for each MODBUS/TCP transaction,
Remark: However the MODBUS client must be capable of accepting a close request
from 
the server and closing the connection. The connection can be reopened when
required.
3) It is recommended for a MODBUS Client to open a minimum of TCP connections with
a remote MODBUS server (with the same IP  address). One connection per application
could be a good choice.
4) Several MODBUS transactions can be ac tivated simultaneously on the same TCP
Connection.
Remark: If this is done then the MODBUS tr ansaction identifier must be used to
uniquely identify the matching requests and responses.
5) In case of a bi-directional communication between two remote MODBUS entities (
each of them is client and server), it is necessary to open separate connections for
the client data flow and for the server data flow.
6) A TCP frame must transport only one MODBUS ADU. It is advised against sending
multiple MODBUS requests or responses on the same TCP PDUModbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Idle
October 24, 2006 http://www.Modbus.org 11/46Connection_established
Request_treatmentWait
Oldest_unused_
connection_closed
Connection_establishmentConnection_accepted
Oldest_unused_no_prioritary_connection_closed
Active_Connection
network_transmissionWait
Request_treatmentConn ect
ion_establishedConnection_acceptedConnection_refused
Active_Connection
network_transmission[connection established]
[Connection OK][<n connections]
[Connection NOK][< n connections][access ctl][connection request]
[IP forbidden][data]
[no access ctl][______Event on a socket[Request to a remote
____
[IP authorized]
[n connections][n connections][else]Server Client 
Figure 7: TCP connection management activity diagram 
1.Explicit TCP connection management
The user application module is in charge of managing all the TCP connections: active 
and passive establishment, connection ending, etc. This management is done for 
all 
MODBUS communication between a client and a server. The BSD Socket interface is used in the user application module to manage the TCP connection. This solution offers 
a total flexibility but it implies that t he application programmer has sufficient TCP 
knowledge. 
A limit of number of client and server conne ctions has to be configured taking into 
account the device capabilities and requirement.  
2. Automatic TCP connection management
The TCP connection management is totally tran sparent for the user application module. 
The connection management module may accept a sufficient number 
of client and 
server connections. 
Nevertheless a mechanism must be implemented in case of exceeding the number of 
authorized connection. In such a case we recommend 
to close the oldest unused 
connection. 
A connection with a remote partner is estab lished at the first packet received from a 
remote client or from the local user application. This connection will be closed if a 
termination arrived from the network or decid ed locally on the device. On reception of a 
connection request, the access control option can be used to forbid device accessibility to unauthorized clients. Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
The TCP connection management module uses th e Stack interface (usually BSD Socket 
interface) to communicate with the TCP/IP stack. 
In order to maintain compatibility between system requirements and server resources, 
the TCP management will maintain 2 pools of connection. 
 The first pool ( priority  connection pool ) is made of connections that are never
closed on a local initiative. A configuration mu st be provided to set this pool up. The 
principle to be implemented is to associat e a specific IP address with each possible 
connection of this pool. The devices with such IP addresses are said to be “marked”. Any new connection that is re quested by a marked device must be 
accepted, and will be taken from the priority connection pool. It is also necessary to 
configure the maximum number of Connections allowed for each remote device to avoid that the same device uses all the connections of the priority pool.  
 The second pool ( non-priority
  connection pool ) contains connections for non
marked devices. The rule that takes over here is to close the oldest connection when a new connection request arrives from a non-marked device and when there is no more connection available in the pool. 
A configuration might be optionally provided  to assign the number of connections 
available in each pool. However (It is not mandatory) the designers can set the number of connections at design time if required. 
4.2.1.2 Connection management description 
•Connection establishment :
The MODBUS messaging service must provide a listening socket on Port 502, which 
permits to accept new connection and to exchange data with other devices.  
When the messaging service needs to exchange  data with a remote s e rver, it must 
open a new client connection with a remote Port 502 in order to exchange data with this distant. The local port must be higher than 1024 and different for each client connection. 
Device Device
Client
Ports
Server
Port502n
(n>1024)
Server
PortClient
Ports
502n
(n>1024) Connection (@ IP1 n,
@IP2 502)@ IP1 @ IP2
Figure 8: MODBUS TCP connection establishment 
If the number of client and server connections is greater than the number of authorized connections the oldest unused connection is closed. The access control mechanism can be activated to check if the IP address of the remote client is authorized. If not the 
new connection is refused. 
October 24, 2006 http://www.Modbus.org 12/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 13/46•MODBUS data transfer
A MODBUS request has to be sent on the righ t TCP connection already opened. The IP 
address of the remote is used to find the TCP connection. In case of multiple TCP 
connections opened with the same remote, one connection has to be chosen to send the MODBUS message, different choice criteria can be used like the oldest one, the first one. The connection has to maintain open during all the MODBUS communications. As described in the following sections a client can initiate several MODBUS transactions with a server without wait ing the ending of the previous one.  
Connection closing
When the MODBUS communications are ended between a Client and a Server, the client has to initiate a connection clos ing of the connection used for these 
communications.  
4.2.2 Impact of Operating Modes on the TCP Connection 
Some Operating Modes (communication br eak between two operational End Points, 
Crash and Reboot on one of the End Point, …) may have impacts on the TCP Connections. A connection can be seen closed or aborted on one side without the 
knowledge of the other side. The connection is said to be " half-open" . 
This section describes the behavior for each main Operating Modes. It is assumed 
 that 
the Keep Alive  TCP mechanism is used on both end points (See section 4.3.2) 
4.2.2.1 Communication break between two operational end points: 
The origin of the communication break can be  the disconnection of the Ethernet cable 
on the Server side. The expected behavior is: 
•If no packet is currently sent on the connection:
The communication break will not be seen if it lasts less than the Keep Alive timer 
value. If the communication break lasts more than the Keep Alive timer value, an error is returned to the TCP Management layer that can reset the connection. 
•If Some packets are sent before and after the disconnection:
The TCP retransmission algorithms (Jacobson's , Karn's algorithms and exponential 
backoff. See section 4.3.2) are activated. This may lead to a stack TCP layer Reset of the Connection before the Keep Alive timer is over. 
4.2.2.2 Crash and Reboot of the Server end point 
After the crash and Reboot of the Server, the connection is "half-open" on Client side. 
The expected behavior is: 
• If no packet is sent on the half-open connection:
The TCP half-open connection is seen opened from the Client side as long as the Keep Alive timer is not over. After that an error is returned to the TCP Management 
layer that can reset the connection. 
•If some packets are sent on the half-open connection:
The Server receives data on a connection that doesn't exist anymore. The stack TCP layer sends a Reset to close the half-open connection on the Client side 
4.2.2.3 Crash and Reboot of the Client 
After the crash and Reboot of the Client, the connection is "half-open" on Server side. 
The expected behavior is: Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 14/46•No packet is sent on the half-open connection:
The TCP half-open connection is seen opened from  the Server side as long as the
Keep Alive timer is not over. After that an error is returned to the TCP Management
layer that can reset the connection.
•If the Client opens a new connection bef ore the Keep Alive timer is over :
Two cases have to be studied:
The connection opening has the same characteristics as the half-open
connection  on the server side (same source and destination Ports, same source
and destination IP Addresses), therefore the connection opening will fail at the
TCP stack level after the Time-Out on Conn ection Establishment (75s on most of
Berkeley implementations). To avoid this long Time-Out during which it is not
possible to communicate, it is advised to ensure that different source portnumbers than the previous one are used for a connection opening after a reboot
on the client side.
The connection opening has not the same characteristics as the half-open
connection  on the server side (different sour ce Ports, same destination Port,
same source and destination IP Address ),  therefore the connection is opened at
the stack TCP level and signaled to the Server TCP Management layer.
If the Server TCP Management layer only su pports one connection from a remote
Client IP Address, it can close the 
old half-opened connection and use the new
one.
If the Server TCP Management layer suppor ts  several connections from a remote
Client IP Address, the new connection stays opened and the old one also stays
half-opened until the expiration of the Keep A live Timer that will return an error to
the TCP Management layer. After that the TCP Management layer will be able to
Reset the old connection.
4.2.3 Access Control Module 
The goal of this module is to check every ne w connection and using a list of authorized 
remote IP addresses the module can authorize or forbid a remote Client TCP 
connection. 
In 
critical context the application progra mmer needs to choose the Access Control 
mode in 
order to secure its network access. In such a case he needs to Authorize/forbid 
access for each remote @IP. The user needs to provide a list of IP addresses and to 
specify for each IP address if it’s authorized or  not. By default, on security mode, the IP 
addresses not configured by the user are forb idden. Therefore with the access control 
mode a connection coming from an unknown IP address is closed. 
4.3 USE of TCP/IP STACK  
A TCP/IP stack provides an interface to manage  connections, to send and receive data, 
and also to do some parameterizations in order to adapt the stack behavior to the device or system constraints.  Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Network AccessNetwork Access
Ethernet II and 802.3 layerEthernet II and 802.3 layer  MsgMsg
TCPTCPModbusModbus
IPIPICMPICMP
ARPARPThe goal of this section is to give 
an overview of the Stack interface and also some information concerning the parameterization of the stack. This overview focuses on the features used by the MODBUS Messaging.  
For more information, the advice is to read the RFC 1122 that provides guidance for 
vendors and designers of Internet communication software. It enumerates standard protocols that a host connected to the Internet  must use as well as an explicit set of 
requirements and options. 
The stack interface is generally based on the BSD (Berkeley Software Distribution) 
Interface that is described in this document. .  
4.3.1 Use of BSD Socket interface 
Remark : some TCP/IP stacks propose othe r types of interfaces for perform ance 
issues. A MODBUS client or server can use these specific interfac es, but this use will 
be not described in this specification. 
A socket is an endpoint of communication. It is the basic building block for 
communication. A MODBUS communication is executed by sending and receiving data 
through sockets. The TCPIP 
library provid es only stream sockets using TCP and 
providing a connection-based communication service. 
The Sockets are created via the socket ()  func tion. A socket number is returned, which 
is then used by the creator to access the socket. Sockets are created without addresses (IP address and port number). Until a port is bound to a socket, it cannot be 
used to receive data.   
The bind ()  function is used to bind a port number to a socket. The 
 bind () creates an 
association between the socket and the port number specified.  
In order to initiate a connection, the client must issue the connect ()  function specifying 
the 
socket number, the remote IP address and the remote listening port number (active 
connection establishment). In order to complete a connection, the server must issue the accept ()  func
 tion 
specifying the socket number that was specified in the prior listen () call (passive 
connection establishment). A new socket is cr eated with the same properties as the 
initial one. This new socket is connected to the client’s socket, and its number is returned to the server. The initial socket is thereby free for other clients that might want to connect with the server. 
After the establishment of the TCP connec tion the data can be transferred. The send()  
and recv() functions are designed specifically to be  used with sockets that are already 
connected. 
The setsockopt ()  f unction allows a socket’s creator to associate options with a socket. 
These options modify the behavior of the so cket. The description of these options is 
given in the section 4.3.2. 
The select ()  func tion allows  the programmer to test events on all sockets. 
October 24, 2006 http://www.Modbus.org 15/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 16/46The shutdown ()  function allows a socket user to disable send () and/or receive () on 
the socket. 
Once a socket is no longer needed, its socket descriptor can be discarded by using the 
close ()  func
tion. 
Figure 39: MODBUS Exchanges describes a full MODBUS communication between a 
client and a s server. The Client establishes the connection and sends 3 MODBUS 
requests to the server without waiting the re sponse of the first one. 
After receiving all 
the responses the Client clos es the connection properly.  Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
CLIENT
( IP1)
fd=socket()
bind(fd,n)
connect(fd,IP2,502)
send(fd)SERVER
(IP2)
fd'=socket()
bind(fd',502)
listen(fd')
fd''=accept(fd')
recv(fd'')
MODBUS Request PDU 1MODBUS Request PDU isend(fd)
recv(fd'')
send(fd")MODBUS Respons e PDU 1recv(fd)
MODBUS Request PDU Nsend(fd)
MODBUS Response PDU irecv(fd)recv(fd'')
MODBUS Response PDU  Nrecv(fd)send(fd")
send(fd")
close(fd)
close(fd")SYN J
SYN K, ACK J+1
ACK K+1
FIN
ACK of FIN
FIN
ACK of FIN
Figure 9: MODBUS Exchanges 
October 24, 2006 http://www.ModbusA.org 17/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 18/464.3.2 TCP  layer parameterization 
Some parameters of the TCP/IP stack can be adjusted to adapt its behavior to the 
product or system constraints. The following parameters can be adjusted in the TCP 
layer: 
•Parameters for each connection:
SO-RCVBUF, SO-SNDBUF:  
These parameters allow setting the high water mark for the Send and the Receive Socket. They can be adjusted for flow control management. The 
size of the received 
buffer is the maximum size advertised window for that connection. Socket buffer sizes must be increased in order to increase performances. Nevertheless these values must be smaller than internal driver resources in order to close the TCP window before exhausting internal driver resources.  
The received buffer size depends on the TCP Windows size, the TCP Maximum 
segment size and the time needed to absorb the incoming frames. 
With a Maximum 
Segment Size of 300 bytes (a MODBUS requ est needs a maximum of 256 bytes + the 
MBAP header size), if we need 3 frames buffering, the socket buffer size value can be adjusted to 900 bytes. For biggest needs and best-scheduled time, the size of the TCP window may be increased.  
TCP-NODELAY:
 
Small packets (called tinygrams) are normally not a problem on LANs, since most LANs 
are not congested, but these tinygrams can lead to congestion on wide 
area networks. 
A simple solution, called the "NAGLE algorithm" , is to collect small amounts of data and 
sends them in a single segment when TC P acknowledgments of previous packets 
arrive.  
In order to have better real-time behavior it is recommended to send small amounts of 
data directly without trying to gather them in a single segment. That is why it is 
recommended to force the TCP-NODELAY option  that disables the 
"NAGLE algorithm" 
on client and server connections.  
SO-REUSEADDR:  
When a MODBUS server closes a TCP connec tion initialized by a remote client, the 
local port number used for this connection cannot be reused for a new 
opening while 
that connection stays in the "Time-wait " state (during two MSL : Maximum Segment 
Lifetime). 
It is recommended specifying the SO-REUSEADDR option for each client and server 
connection to bypass this restriction. This op tion allows the process to assign itself a 
port number that is part of a connection that is in the 2MSL wait 
for client and listening 
socket. 
SO-KEEPALIVE:  
By default on TCP/IP protocol no data ar e sent across an idle TCP connection. 
Therefore if no process at the ends of a TC P connection is 
sending data to the other, 
nothing is exchanged between the two TCP modules. This assumes that either the 
client application or the server application uses  timers to detect inactivity in order to 
close a connection. 
It is recommended to enable the KEEPALIVE option on both client and server 
connection in order to poll the other end to know if the distant has either crashed and 
is 
down or crashed and rebooted. 
Nevertheless we must keep on mind that enabling KEEPALIVE can cause perfectly 
good connections to be dropped during transient failures, that it consumes unnecessary 
bandwidth on the network if the keep alive timer is too short. Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
•Parameters for the whole TCP layer:
Time Out on establishing a TCP Connection:  
Most Berkeley-derived systems set a time limit  of 75 seconds on the establishment of a 
new connection, this default value should be adap ted to the real time constraint of the 
application. 
Keep Alive parameters:  
The default idle time for a connection is 2 hours. Idles times in excess of this value 
trigger a keep alive probe. After the first ke ep alive probe, a probe is sent every 75 
seconds for a maximum number of times unless a probe response is received. 
The maximum number of keep Alive probes sent out on an idle connection is 8. If no 
probe 
response is received after sending out the maximum number of keep Alive 
probes,TCP signals an error to the application that can decide to close the connection  
Time-out and retransmission parameters:
A TCP packet is retransmitted if its loss has been detected. One way to detect the loss 
is to manage a Retransmission Time-Out (RTO) that expires if no acknowledgement has been received from the remote side.  
TCP manages a dynamic estimation of the RTO.  For that purpose a 
 Round-Trip Time 
(RTT) is measured after the send of every packet that is not a retransmission. The 
Round-Trip Time (RTT) is the time taken for a packet to reach the remote device and to 
get back an acknowledgement to the sending device. The RTT of a connection is calculated dynamically, nevertheless if TCP ca nnot get an estimate within 3 seconds, 
the default value of the RTT is set to 3 seconds. 
If the RTO has been estimated, it applies to the next packet sending. If the acknowledgement of the next packet is not received before 
the estimated RTO 
expiration, the Exponential BackOff  is activated. A maximum number of 
retransmissions of the same packet is allowe d during a certain amount of time. After 
that if no acknowledgement has been rece ived, the connection is aborted.  
The maximum number of retransmissions and the maximum amount of time before the abort of the connection (tcp_ip_abort_interval) can be set up on some stacks. 
Some retransmission algorithms are defined in TCP standards :  
The Jacobson's RTO estimation algorithm  is  used to estimate the
Retransmission Time-Out (RTO),
The Karn's algorithm  says  that the RTO estimation should not be done on a
retransmitted segment,
 The Exponential BackOff  defines that the retransmission time-out is doubled for
each retransmission with an upper limit of 64 seconds.
The fast retransmission algorithm  allows retrans mitting after the reception of
three duplicate acknowledgments. This algo rithm is advised because on a LAN it
may lead to a quicker detection of the loss of a packet than waiting for the RTO
expiration.
The use of these algorithms is recommended for a MODBUS implementation.  
4.3.3 IP layer parameterization 
4.3.3.1 IP Parameters 
The following parameters must be configured in the IP layer of a MODBUS 
implementation : 
•Local IP Address : the IP address can be part of a Class A, B or C.
•Subnet Mask, : Subnetting an IP Network can be done for a variety of reasons : use of
different physical media (such as Ethernet, WAN, etc.), more efficient use of 
October 24, 2006 http://www.Modbus.org 19/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
network addresses, and the capability to control network traffic. The Subnet Mask 
has to be consistent with the IP addr ess class of the local IP address. 
• Default Gateway:  The IP address of the default gateway has to be on the same
subnet as the local IP address. The value 0.0. 0.0 is forbidden. If no gateway is to be 
defined then this value is to be set to eith er 127.0.0.1 or the Local IP address. 
Remark : The MODBUS messaging service doesn' t require the fragmentation function in 
the IP layer. 
The local IP End Point shall be configured with a local IP Address  and with a Subnet 
Mask and a Default Gateway  (different from 0.0.0.0) . 
4.4 COMMUNICATION APPLICATION LAYER 
4.4.1 MODBUS Client 
Modbus
Client
TCP/IP
Modbus
Server
TCP/IPModbus
Server
TCP/IPModbus
Server
Serial LineModbus
Server
Serial LineModbus
Client
Serial Line
Modbus
Client
TCP/IP
Modbus TCP / IPClient TCP/IP
gateway
Server TCP/IP
gateway
Modbus Serial line
Figure 10: MODBUS Client unit 
4.4.1.1 MODBUS client design 
The definition of the MODBUS/TCP protocol allows a simple design of a client. The 
following activity diagram describes the main treatments that are processed by a client 
to send a MODBUS request and to treat a MODBUS response. 
October 24, 2006 http://www.Modbus.org 20/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Send negative
confirmation to user
ApplicationProcess
MODBUS
Confirmation
Set Waiting
response timerSend MODBUS request
To TCP managementWait
Find out pending
transactionIdle
Send positive
confirmation toUser ApplicationBuild MODBUSrequestWaitIdle
[Retries number reached][Request_from_the_user application]
[Confirmation error]Waiting_response_timer_expires[Reveive_Response_from_TCP_Mgt]
[Retries number not reached]
[Confirmation OK]
[Send Not OK] [Send OK]
Figure 11: MODBUS Client Activity Diagram 
A MODBUS client can receive three events:  
A new demand from the user application to  send a request , in this case a MODBUS
request has to be encoded and be sent on the network using the TCP management component service. The lower layer ( TCP management module) can give back an error due to a TCP connection error, or some other errors. 
 A response from the TCP management, in th is 
 case the client has to analyze the
content of the response and send a conf irmation to the user application 
The expiration of a Time out due to a non-response. A new retry can be sent on the
network or a negative confirmation can be  sent to the User Application. 
Rem
ark : These retries are initiated by the MODBUS client, some other retries can 
also be done by the TCP layer in case of TCP acknowledge lack. 
4.4.1.2 Build a MODBUS Request 
Following the reception of a demand from the user  application, the client has to build a 
MODBUS request and to send it  to the TCP management.  
Building the MODBUS request can be split in several sub-tasks:  
The instantiation of a MODBUS transaction that enables the Client to memorize all
required information in order to bind later the response to the request and to send the confirmation to the user application. 
The encoding of the MODBUS request (PDU + MPAB header). The user application
that initiates the demand has to provide a ll required information which enables the 
Client to encode the request. The MODBUS PDU is encoded according to 
the 
MODBUS Application Protocol Specificat ion [1]. (MB function code, associated 
parameters and application data ). All fiel ds of the MBAP header are filled. Then, 
the MODBUS request ADU is built pref ixing the PDU with the MBAP header 
October 24, 2006 http://www.Modbus.org 21/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
The sending of the MODBUS request ADU to the TCP management module which is
in charge of finding the right TCP socket to wards the remote Server. In addition to 
the MODBUS ADU the Destination IP address must also be passed. 
The following activity diagram describes, more deeply than in Figure 11 MODBUS 
Client Activity Diagram, the request building phase. 
Instantiate a MB 
transaction
Initialize the transaction
Send MB request to TCP Mgt Send a negative confirmation to the user applicationEncode the MB request PDU 
Encode the MBAP header[No Transaction available]
[Transaction available]
Figure 12: Request building activity diagram 
The following example describes the MODBUS request ADU encoding for reading the 
register # 5 in a remote server : 
♦MODBUS Request ADU encoding :
Description Size Example 
Transaction Identifier  Hi 1 0x15 
Transaction Identifier  Lo 1 0x01 
Protocol Identifier 2 0x0000 
Length 2 0x0006MBAP Header  
Unit Identifier 1 0xFF 
October 24, 2006 http://www.Modbus.org 22/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 23/46Function Code (*) 1 0x03 
Starting Address 2 0x0004 MODBUS 
request 
Quantity of Registers 2 0x0001 
(*) please see the MODBUS Applic ation Protocol Specification [1]. 
•Transaction Identifier
The transaction identifier is used to associate the future response with the request.
So, at a time, on a TCP connection, this identifier must be unique. There are
several manners to use the transaction identifier:
-For example, it can be used as a simple "TCP sequence number" with a
counter which is incremented at each request.
-It can also be judiciously used as a sm art index or pointer to identify a
transac
tion context in order to memorize the current remote server and the
pending MODBUS request.
Normally, on MODBUS serial line a client mu st send one request at a time. This means 
that the client must wait for the answer to the first request before sending a second 
request. On TCP/MODBUS, several requests can be sent without waiting for a confirmation to the same server.  The MODB US/TCP to MODBUS serial line gateway is 
in charge of ensuring compatibility between these two behaviors.   
The number of requests accepted by a serv er depends 
 on its capacity in term of 
number of resources and size of the TCP wi ndows. In the same way the number of 
transactions initialized simultaneously by a cli ent depends also on its resource capacity. 
This implementation parameter is called " NumberMaxOfClientTransaction " and must 
be described as one of the MODBUS client fe atures. Depending of the device type this 
parameter can take a value from 1 to 16.  
•Unit Identifier
This field is used for routing purpose when addressing a device on a MODBUS+
or MODBUS se
rial line sub-network. In that case, the “Unit Identifier” carries the 
MODBUS slave address of the remote device: 
If the MODBUS server is connected to a MODBUS+ or MODBUS Serial Line 
sub-network and 
addressed through a bridge or a gateway, the MODBUS Unit 
identifier is necessary to identify th e slave device connected on the sub-
network behind the bridge or the gateway. The destination IP address identifies the bridge itself and the bridge  uses the MODBUS Unit identifier to 
forward the request to the right slave device. 
The MODBUS slave device addresses on serial line are assigned from 1 to 
247 (decimal). Address 0 is used as broadcast address. 
On TCP/IP, the MODBUS 
server is addresse d using its IP address; therefore, the 
MODBUS Unit Identifier is useless.  The value 0xFF has to be used. 
When addressing a MODBUS server connec ted directly to a TCP/IP network, 
it’s recommended not using a significant MODBUS 
slave address in the “Unit 
Identifier” field. In the event of a re-allo cation of the IP addresses within an 
automated system and if a IP address previously assigned to a MODBUS 
server is then assigned to a gateway, using a significant slave address may 
cause trouble because of a bad routing by the gateway. Using a non-significant slave address, the gateway will simply discard the MODBUS PDU 
with no trouble. 0xFF is recommended for the “Unit Identifier" as non-significant value. 
Remark : The value 0 is also accepted to communicate directly to a 
MODBUS/TCP device . Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 24/464.4.1.3 Process MODBUS Confirmation 
When a response frame is received on a TC P connection, the Transaction Identifier 
carried in 
the MBAP header is used to associate the response with the original request 
previously sent on that TCP connection: 
 If the Transaction Identifier doesn't refer to any MODBUS pending transaction, the
response must be discarded. 
 If the Transaction Identifier refers to a MODBUS pending transaction, the response
must be 
parsed in order to send a MODBUS Confirmation to the User Application 
(positive or negative confirmation) 
Parsing the response consists in verify ing the MBAP Header and the MODBUS PDU 
response: 
MBAP Header
After the verification of the Protocol Identif ier that must be 0x0000, the length gives 
the size of the MODBUS response. 
If the response comes from a MODBUS serv er device directly connected to the 
TCP/IP 
network, the TCP connection identification is sufficient to unambiguously 
identify the remote server. Therefore, the Unit Identifier carried in the MBAP 
header is not significant (value 0xFF) and must be discarded. If the remote server is connected on a Serial Line sub-network and the response 
comes from a bridge, a router or 
a gateway,  then the Unit Identifier (value != 0xFF) 
identifies the remote MODBUS server which has originally sent the response. 
MODBUS Response PDU
The function code must be verified and the MODBUS response format analyzed according to the MODBUS Application Protocol: 
•if the function code is the same as the one used in the 
 request, and if the
response format is correct, then the MODBUS response is given to the user
application as a Positive Confirmation .
•If the function code is a MODBUS exception code (Function code + 80H), the
MODBUS exception response is give n to the user application as a Positive
Confirmation.
•If the function code is different from  the one used in the request (=non
expected function code), or if the format  of the response is incorrect, then an
error is signaled to the user application using a Negative Confirmation .
Remark: A positive confirmation is a confirmation that the command was received and 
responded to by the server. It does not imply that the server was able to successfully act on the command (failure to successfully act on the command is indicated by the MODBUS Exception response). 
The following activity diagram describes, more deeply than in Figure 11 MODBUS 
Client Activity Diagram, the confirmation processing phase. Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Use MB transaction to 
bind with the re quest
Process_M B_exceptionFind Out pending MB transaction
Extract MB ResponseDiscard 
Response
Analyse MBAP header
Analyse Response 
PDU
WaitSend positive confirmation to user 
applicationSend negative 
Confirmation to user Application
Wait[Modbus_protocol][No Pending Transaction ]
[Incorrect Response][Other_protocol]
[MB Exception response][MB response OK][PendingTransaction ]
Figure 13: Process MODBUS Confirmation activity diagram 
4.4.1.4 Time-out management 
There is deliberately NO specification of requ ired response time for a transaction over 
MODBUS/TCP.  
This is because MODBUS/TCP is expected to be used in the widest possible variety of 
communication situations, from I/O scanners expecting sub-millisecond timing to long 
distance radio links with delays of several seconds. 
From a client perspective, the timeout must take into account the expected transport 
delays across the network, to determine a ‘reasonable’ response time. 
Such transport 
delays might be milliseconds for a switched Et hernet, or hundreds of milliseconds for a 
wide area network connection. 
In turn, any ‘timeout’ time used at a client to  initiate an application retry should be 
larger than the expected maximum ‘reasonable’ response time. If this is 
not followed, 
there is a potential for excessive congestion at  the target device or on the network, 
which may in turn cause further errors. This is a characteristic, which should always be 
avoided. 
October 24, 2006 http://www.Modbus.org 25/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
So in practice, the client timeouts used in high performance applications are always 
likely to be somewhat dependent on network topo logy and expected client performance. 
Applications which are not time critical c an often leave timeout values to the normal 
TCP defaults, which will report communication failure after several seconds on most 
platforms. 
4.4.2 MODBUS Server 
Modbus
Client
TCP/IP
Modbus
Server
TCP/IPModbus
Server
TCP/IPModbus
Server
Serial LineModbus
Server
Serial LineModbus
Client
Serial Line
Modbus
Client
TCP/IP
Modbus TCP / IPClient TCP/IP
gateway
Server TCP/IP
gateway
Modbus Serial line
Figure 14: MODBUS Server unit 
The role of a MODBUS server is to provid e access to application objects and services 
to remote MODBUS clients. 
Different kind of access may be provided depending on the user application : 
simple access like get and set application objects attributes
advanced access in order to trigger specific application services
The MODBUS server has: 
To map application objects onto readable an d writable MODBUS objects, in order
to get or set applicati on objects attributes.
To provide a way to trigger services onto application objects.
In run time the MODBUS server has to  analyze a received MODBUS request, to 
process the required action, and to send back a MODBUS response. Informative Note:  The application objects and se
 rvices of the Backend Interface obtain 
the requested data based upon the function code, and the User is responsible.  
October 24, 2006 http://www.Modbus.org 26/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
4.4.2.1 MODBUS Server Design 
The MODBUS Server design depends on both : 
the kind of access to the application objects (simple access to attributes or
advanced access to services)
the kind of interaction between the MO DBUS server and the user application
(synchronous or asynchronous).
The following activity diagram describes the main treatments that are processed by the 
Server to obtain a MODBUS request from TCP Management, then to analyze the 
request, to process the required action, and to send back a MODBUS response. 
Build a MODBUS
responseWait
MODBUS_PDU_Checking...Idle
Build a MODBUSException
Send responseto TCP_MgtMODBUS_Service_ProcessingInvoke backend interface
Response
processing
Release the
MODBUS server
transactionWait
MODBUS_PDU_Checking...
[Processing OK] [Processing OK][Need user application processing][Server init]
[Reception of a MODBUS indication
from TCP Mgt][Response from user application]
[MODBUS transaction accepted][MB transaction refused][MB Indication discarded][Invocation user application done]
[Processing not OK][Processing not complete]
[MB Exception OK]
[processing ends][Processing not OK]
[MB Response OK]
Figure 15: Process MODBUS Indication activity diagram 
October 24, 2006 http://www.Modbus.org 27/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 28/46As shown in the previ ous activity diagram: 
Some services can be immediately proce ssed by the MODBUS Server itself, with
no direct interaction with the User Application ;
Some services may require also interactin g explicitly with the User Application to
be processed ;
Some other advanced services require invoking a specific interface called
MODBUS Back End service. For example, a User Application service may be
triggered using a sequence of several MODBUS request/response transactions
according to a User Application level protocol. The Back End service is
responsible for the correct processing of all individual MODBUS transactions inorder to execute the global User Application service.
A more complete description is given in the following sections. 
The MODBUS server can accept to serve simultaneously several MODBUS requests. 
The maximum number of simultaneous MODBUS requests the server can accept is one of the main characteristics of a MODBUS se rver. This number depends on the server 
design and its processing and memory capabilities. This implementation parameter is 
called " NumberMaxOfSeverTransaction " and must be described as one of the 
MODBUS server features. It may have a value from 1 to 16 depending on the device 
capabilities.  
The behavior and the performance of the MODBUS  server are significantly affected by 
the "NumberMaxOfTransaction" parameter. Partic ularly, it's important to note that the 
number of concurrent MODBUS transactions managed may affect the response time of 
a MODBUS request by the server. 
4.4.2.2 MODBUS PDU Checking 
The following diagram describes the MODBUS PDU Checking activity.  Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Parse the
MBAP header
Instantiate aMB TransactionMB Indicationdiscarded
MB Transaction
refused
MB Transaction
acceptedParse The MBPDU[MBAP OK]
[Transaction available]
[OK][No Transaction available]
[Error on MB PDU][Error on MBAP ]
Figure 16: MODBUS PDU Checking activity diagram 
The MODBUS PDU Checking function consists of first parsing the MBAP Header. The 
Protocol Identifier field has to be checked :  
If it is  different from MODBUS protocol type, the indication is simply discarded.
If it is correct (= MODBUS protocol type; value 0x00), a MODBUS transaction is
instantiated.
The maximum number of MODBUS transactions th e server can instantiate is defined by 
the "NumberMaxOfTransaction" parameter ( A system or a configuration parameter). 
In case of no more transactions availabl e, the server builds a MODBUS exception 
response (Exception code 6 : Server Busy). 
If a MODBUS transaction is available, it's in itialized in order to memorize the following 
information:  
•The TCP c onnection identifier used to send the indication (given by the TCP
Management)
•The MODBUS Trans action ID (given in MBAP Header)
•The Unit Identifier (given in MBAP Header)
Then the MODBUS PDU is parsed.  The function code is first controlled :  
in case of invalidity a MODBUS exception re sponse is built (Exception code 1 : Invalid
function). 
 If the function code is accepted, the server initiates the "MODBUS Service
proces
sing" activity. 
October 24, 2006 http://www.Modbus.org 29/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
4.4.2.3 MODBUS service processing 
Analyse
requested service
Local Service
processing
Build ModbusResponseBuild ModbusException ResponseSend an invocation to
User Application
through MB Backend
interfaceResponseprocessing
[Need User App processing]
[Completed][Local processing ]Transaction_accepted
[Processing OK][Processing not completed]
[Processing  not OK]Response_from_user_App
[Processing OK]
[Processing Not OK]
Figure 17: MODBUS service processing activity diagram 
The processing of the required MODBUS service can be done in different ways 
depending on the device software and hardware architecture as described in the hereafter examples :  
•Within a compact device or a mono-th read architecture where the MODBUS
server can access direct
ly to the user ap plication data, the required service can
be processed "locally" by the server itse lf without invoking the Back End service.
The processing is done according to the MODBUS Application Protocol
Specification [1]. In case of an error, a MODBUS exception response is built.
•Within a modular multi-processor device or  a multi-thread architecture where the
"communication layers" and the "user applic ation layer" are 2 separate entities,
some trivial services can be processed co mpletely by the Communication entity
while some others can require a cooperat ion with the User Application entity
using the Back End service.
To interact with the User Application, the MODBUS Backend service must implement all appropriate mechanisms in order to handle User Application transactions and to 
manage correctly the User Application invocations and associated responses. 
4.4.2.4 User Application Interface (Backend Interface) 
Several strategies can be implemented in the MODBUS Backend service to achieve its 
job although they are not equivalent in te rms of user network throughput, interface 
bandwidth usage, response time, or even design workload. 
October 24, 2006 http://www.Modbus.org 30/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 31/46The MODBUS Backend service will use the appropriate interface to the user 
application : 
Either a physical interface based on a seri al link, or a dual-port RAM scheme, or
a simple I/O line, or a logical interface based on messaging services provided by
an operating system.
The interface to the User Applicati on may be synchronous or asynchronous.
The MODBUS Backend service will also use the appropriate design pattern to get/set objects attributes or to trigger services. In some cases, a simple "gateway pattern" will be adequate. In some other cases, the designer will have to implement a "proxy pattern" with a corresponding caching strategy, from a simple exchange table history to more sophisticated replication mechanisms. 
The MODBUS Backend service has the resp onsibility to implement the protocol 
transcription in order to interact with the Us er Application. Therefore, it can have to 
implement mechanisms for packet fragmentation/reconstruction, data consistency 
guarantee, and synchronization whatever is required. 
4.4.2.5 MODBUS Response building 
Once the request has been processed, the MO DBUS  server has to build the response 
using the adequate MODBUS server transact ion and has to send it to the TCP 
management component. 
Depending on the result of the processing two types of response can be built :  
A positive MODBUS response :
The response function code = The request function code
A MODBUS Exception response :
The objective is to provide to the client relevant information concerning the
error detected during the processing ;
The response function code = the request function code + 0x80 ;
The exception code is provided to indicate the reason of the error.
Exception 
Code MODBUS name Comments 
01 Illegal Function 
Code The function code is unknown by the server 
02 Illegal Data 
Address Dependant on the request 
03 Illegal Data Value Dependant on the request 
04 Server Failure The server failed during the execution 
05 Acknowledge The server accepted the service invocation but the 
service requires a relatively long time to 
execute. The 
server therefore returns onl y an acknowledgement of the 
service invocation receipt. 
06 Server Busy The server was unabl e to accept the MB Request PDU. 
The client application has the responsibility of deciding if 
and when to re-send the request. 
0A Gateway problem Gateway paths not available. 
0B Gateway problem The targeted devic e failed to respond. T he gateway 
generates this exception 
The MODBUS response PDU must be prefixed with the MBAP header which is built 
using data memorized in the transaction context. 
•Unit Identifier
The Unit Identifier is copied as it was gi ven within the received MODBUS request
and memorized in the transaction context.Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
•Length
The server calculates the size of the MODBUS PDU plus the Unit Identifier byte.
This value is set in the "Length" field.
•Protocol Identifier
The Protocol Identifier field is set to 0x 0000 (MODBUS protocol), as it was given
within the received MODBUS request.
•Transaction IdentifierThis field is set to the "Transaction Identif ier" value that was associated with the
original request and memorized in the transaction context.
Then the MODBUS response must be returned to the right MODBUS Client using the 
TCP connection memorized in the transaction context. When the response is sent, the 
transaction context must be free. 
5 IMPLEMENTATION GUIDELINE 
The objective of this section is to propose an example of a messaging service 
implementation.  
The model describes below can be used as a guideline during a client or a server 
implementation of a MODBUS messaging service. 
Informative Note:  The messaging service implementation is the responsibility of the User. 
5.1 OBJECT MODEL DIAGRAM 
Communication application layer
TCP managementConfiguration layerInterfaceUserApplication
InterfaceIndicationMsg InterfaceResponseMsgUser Application
Figure 18: MODBUS Messaging Service Object Model Diagram  
October 24, 2006 http://www.Modbus.org 32/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 33/46Four main packages compose the Object Model Diagram: 
•The Configuration lay e r which configures and manages operating modes of
components of other packages
•The TCP Management  which interfaces the TCP/IP stack and the communication
application layer managing TCP connection. It implies the management of socket
interface.
•The Communication application lay er which is composed by the MODBUS client
on one side and the MODBUS server on the other side. This package is linked
with the user application.
The User application, which corresponds to the device application, is completely dependent 
on  the device and therefore it will be not part of this Specification.  
This model is independent of implementation choices like the type of OS, the memory 
management, etc.  In order to guarantee this independence generic Interface layers 
are 
used between the TCP management layer and the communication layer and between 
the communication layer and the user application layer. 
Different implementations of this interface can be realized by the User: Pipe between 
two tasks, shared memory, serial link interface, procedural call, etc. 
Some assumptions  have to be  taken to define the hereafter implementation model : 
•Static memory management
•Synchronous treatment of the server
•One task to process the receptions on all sockets.
5.1.1 TCP management package Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
-----------------------------------------------------------------------------------------------------------------------------------------------
TCP manage ment 
packageInterfaceIndicationMsg
(from Logical View)InterfaceResponseMsg
(from Logical View)
ItemConnexion
SocketDescript : Int
IPSource : Long
PortSource : Long
PortDest : Long
IPdestination : long
BufferIn : Char*
BufferOut : Char*ConnexionMgt
NbConnectionSupported : Int
NbLocalConnection : Int
NbRemoteConnection : int
m_sendData()
m_Receivedata()
m_isConnectionAuthorized()InterfaceConnexion
GetObjectConnexion()
FreeObjectConnexion()
RetreivingObjectConnexion()
MBAP
IsMdbHeader()
GetMessagelength()
WriteTransactionId()
ReadTransactionId()TCPConnexion
IsConnexionRequest()
OpenConnexion()
AcceptConnexion()
CloseConnexion()
IsEtablishedConnexion()
StackTCP IP
Socket interface()
Figure 19: MODBUS TCP management package 
The TCP management package comprises the following classes :  
CInterfaceConnexion: The role of this class consists in managing memory pool for 
connections.  
CItemConnexion: This class contains all information needed to describe a connection. CTCPConnexion :, This class provides methods for managing automatically a TCP 
connection (Interface socket is provided by CStackTCP_IP ). 
CConnexionMngt : This 
 class manages all connections and send query/response to 
MODBUS Server/MODBUS Client through CinterfaceIndicationMsg and 
CInterfaceResponseMsg . This class also treats the Access control for the connection 
opening. 
CMBAP : This class provides methods for re ading/writing/analyzing the MODBUS 
MBAP. 
CStackTCP_IP: This class  Implements  socket services and provides parameterization 
of the stack. 
October 24, 2006 http://www.Modbus.org 34/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
5.1.2 Configuration layer package 
Operating Mode
m_Configure()
m_Start()
m_Stop()
m_Reset()
ConfigurationObject
GlobalState : char
MyM odbusAddress  : Int
MyIPAddress : long
MyPortNumber : Long
NumberAuthorized_IP : int
ListAuthorized_IP : int
NumberForbidden_IP : Int
ListForbidden_IP : long()
NumberConnectionSupported : intTCP management
(from Logical View)Communication application layer
(from Logical View)
------------------------------------------------------------------------------------------------------------------------------------------------
Configuartion layer 
package
Figure 20: MODBUS Configuration layer package 
The Configuration layer package comprises the following classes :  
TConfigureObject: This class groups all data needed for configuring each other 
component. This structure is filled by the method m_Configure from the class 
CoperatingMode . Each class needing to be configured gets its own configuration data 
from this object. The configuration data is implementation dependent therefore the list 
of attributes of this class is provided as an example.  
COperatingMode:  The role of this class is to fill the TConfigureObject  (according to 
the user configuration) and to 
manage the operating modes of the classes described 
below:   
CMODBUSServer
CMODBUSClient
October 24, 2006 http://www.Modbus.org 35/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
CconnexionMngt
5.1.3 Communication layer package 
InterfaceUserApplication
(from Logical View)
ModbusServer
m_ServerReceivingMessage()
m_ServerModbus()
m_BuildResponse()
m_InitServerfunction()ModbusPDU
IsMdbAnalysisOfDataCorrect()
m_BuildModbusException()
m_WritePDU()
Transaction
TransactionId : int
TimeSnapShot : int
IsTransactionTimeOut()
m_WriteTransactionID()
m_StartTimesnapShoot()
InterfaceResponseMsg
(from Logical View)InterfaceIndicationMsg
(from Logical View)ModbusClient
m_ClientReceiv ingResponse()
m_ClientReceiv ingMessage()
m_ClientModbus()--------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------Communication 
Application layer package
Figure 21: MODBUS Communication Application layer package 
The Communication Application layer package comprises the following classes :  
CMODBUSServer : MODBUS query is received from class CInterfaceIndicationMsg 
(by the method m_ServerReceivingMessage). The role of this class is to build the 
MODBUS response or the MODBUS Exceptio n according the query (incoming from 
network). This class implements the Graph St ate of MODBUS server. Response can be 
built only if class COperatingMode has sent both user configuration and right operating 
modes. 
CMODBUSClient : MODBUS query is read from class CInterfaceUserApplication , The 
client task receives query by the 
method m_ClientReceivingMessage. This class 
October 24, 2006 http://www.Modbus.org 36/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 37/46implements the State Graph of MODBUS client and manages transactions for linking 
query with response (from network). Query ca n be sent over network only if class 
CoperatingMode has sent both user configuration and right operating modes. 
CTransaction : This class implements methods and structures for managing 
transactions.  
5.1.4 Interface classes 
CInterfaceUserApplication: This class represents the interface with the user 
application, it provides two methods to  access to the user data. In a real 
implementation this method can be implemented in different way depending of the 
hardware and software device capabilities (equivalent to an end-driver, example access to PCMCIA, shared memory, etc). 
CInterfaceIndicationMsg: This Interface class is proposed for 
 sending query from 
Network to the MODBUS Server, and for sendi ng response from Network for the Client. 
This class interfaces TCPManagement and ‘Communication Application Layer’ 
packages (From Network). The implementati on of this class is device dependent. 
 CInterfaceResponseMsg : This Interface class is used for receiving response from the 
Server and for sending query from the client to the Network. This class interfaces 
packages ‘Communication Application Lay er’ and package ‘TCPManagement’ (To 
Network). The implementation of this class is device dependent. 
5.2 IMPLEMENTATION CLASS DIAGRAM 
The following Class Diagram describes the complete diagram of a proposal implementation.  Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 38/46
Figure 22: Class DiagramModbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 39/465.3 SEQUENCE DIAGRAMS 
Two Sequence diagrams are described hereafter are an example in order to illustrate a 
Client MODBUS transaction and a Server MODBUS transaction.  
Figure 23: MODBUS client sequence diagram Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 40/46General comments for a better understanding of the Client  sequence diagram : 
First step : A Reading query comes from User Application (method m_Read).  
Second Step : The ‘Client’ task  receives the MODBUS query  (method 
m_ClientReceivingMessage). This is the entry point of the Client. To associate the 
query with the corresponding response when it will arrive, the Client uses a 
Transaction resource (Class CTransaction ). The MODBUS query is sent to the 
TCP_Management by calling the class interface CInterfaceResponseMsg  (method 
m_MODBUSRequest) 
Third Step:  If the connection is already estab lished there is nothing to do on 
connection, the message can be send over the network. Otherwise, a connection must be opened before the message can be sent over the network. 
At this time the client is waiting for a  response (from a remote serv er)  
Fourth step:  Once a response has been received from the network, the TCP/IP stack 
receives  data (method m_EventOnSocket  is implicitly called). 
 If the connection is already established, th en the MBAP is read for retrieving the 
connection object (connection  object gives memory resource and other information). 
Data coming from network is read and confirmation is sent to the client  task  via the 
class Interface CInterfaceIndicationMsg (method m_MODBUSConfirmation). Client 
task receives the MODBUS Confirmation (method m_ClientReceivingResponse ). 
Finally the  response is  written  to the  user application (method m_WriteData), and 
transaction resource is freed . Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 41/46Hereafter is an example of a MODBUS Server exchange. 
Figure 24: MODBUS server Diagram Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 42/46General comments for a better understanding of the Server sequence diagram : 
First step : a client has sent a query (MOD BUS query) over the network.  
The TCP/IP stack receives data (method m_Ev entOnSocket  is implicitly called).  
Second step : The query  may be a connection request or not (method 
m_IsConnexionRequest). 
If the query is a connection request,  the connection  object and buffers for receiving 
and sending 
the MODBUS frame are allocated (method m_GetObjectConnexion ). 
Just after, the connection access control must be checked and accepted  (method 
m_AcceptConnexion) 
Third step:  If the query is a MODBUS request, the complete MODBUS Query can be 
read (method m_ReceiveData ). At this time the MBAP must be analyzed (method 
m_IsMdbHeaderCorrect ). The complete frame is sent to the Server task  via the 
CinterfaceIndicationMessaging  Class (method m_MODBUSIndication). Server task 
receives the MODBUS Query (method m_ServerReceivingMessage ) and analyses it. 
If an error occur s (function code not supported, etc) , a MODBUSException frame is 
built ( m_BuildMODBUSException), otherwise the response is built. 
Fourth Step:  The response is sent over the network via the 
CinterfaceResponseMessaging (method m_MODBUSResponse). Treatment on the  
connection object  is done by the method m_SendData  (retrieve the connection 
descriptor, etc) and data is  sent over the network. 
5.4 CLASSES AND METHODS DESCRIPTION 
5.4.1 MODBUS Server Class 
Class CMODBUSServer 
class CMODBUSServer   
Stereotype implementationClass 
Provides methods for managing MODBUS Messaging in Server Mode  
Field Summary  
GlobalState  
state of the MODBUS Server protected char
Constructor Summary  
CMODBUSServer (TConfigureObject * lnkConfigureObject)
Constructor : Create internal object  
Method Summary  Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 43/46m_InitServerFunctions (void )
Function called by the constructor for filling array of functions 
'm_ServerFunction' protected void
m_Reset(void )
Method for Resetting Server, return true if reset bool
m_ServerReceivingMessage (TItemConnexion * lnkMODBUS)
Interface with CindicationMsg::m_MOD BUSIndication for receiving Query 
from NetWork return negative value if problem int
m_Start(void )
Method for Starting Server, return true if Started bool
m_Stop(void )
Method for Stopping Server, return true if Stopped bool
m_tServerMODBUS (void )
Server MODBUS task ... protected void
5.4.2 MODBUS Client Class 
Class CMODBUSClient 
class CMODBUSClient   
Provides methods for managing MODBUS Messaging in Client Mode  
Stereotype implementationClass 
Field Summary  
protected 
charGlobalState  
State of the MODBUS Client 
Constructor Summary  
CMODBUSClient (TConfigureObject * lnkConfigureObject)
Constructor : Create internal obj ect , initialize to 0 variables. 
Method Summary  
m_ClientReceivingMessage (TItemConnexion * lnkMODBUS)
Interface provided for receiving message from application Layer Typically : Call CinterfaceUserApplication::m_Read for reading 
data call 
CInterfaceConnexion::m_GetObjectCo nnexion for getting memory for a 
transaction. Return negative value if problem int
m_ClientReceivingResponse (TitemConnexion *
lnkTItemConnexion)  
Interface with Cindic
ationMsg::m_Confirmation for receiving response from 
network return negative value if problem int
m_Reset(void )
Method for Resetting component, return true if reset bool
m_Start(void )
Method for Starting component, return true if started bool
bool m_Stop(void )Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 44/46Method for Stopping component, return true if stopped 
m_tClientMODBUS (void )
Client MODBUS task.... protected void
5.4.3 Interface Classes  
5.4.3.1 Interface Indication class 
Class CInterfaceI ndicationMsg 
Direct Known Subclasses:   
CConnexionMngt
class CInterfaceIndicationMsg 
Class for sending message from TCP_Management  to MODBUS  Server or Client  
Stereotype interface 
Method Summary  
m_MODBUSConfirmation (TItemConnexion * lnkObject)
Method for Receiving incoming Response, calling the Client : could be by 
reference, by Message Queue, Remote procedure Call, ... int
m_MODBUSIndication (TItemConnexion * lnkObject)
Method for reading incoming MODBUS Query and calling the Server : could be by referenc
e, by Message Queue, Remote procedure Call, ... int
5.4.3.2 Interface Response Class 
Class CInterfaceResponseMsg 
Direct Known Subclasses:   
CMODBUSClient , CMODBUSServer
class CInterfaceResponseMsg  
Class for sending response or sending query to TCP_Management from Client or Server  
Stereotype interface 
Method Summary   TitemConnexion 
*m_GetMemoryConnexion (unsigned long IPDest)
Get an object ITemConnexion from memory pool. Return -1 if not enough memory 
int m_MODBUSRequest (TItemConnexion * lnkCMODBUS)
Method for Writing incoming MODBUS Query Client to ConnexionMngt : Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 45/46could be by reference, by Message Queue, Remote procedure Call, ... 
m_MODBUSResponse (TItemConnexion * lnkObject)
Method for writing Response from MO DBUS Server to ConnexionMngt 
c
ould be by reference, by Message Queue, Remote procedure Call, ... int
5.4.4 Connexion Management class 
Class CConnexionMngt 
class CConnexionMngt   
Class that manages all TCP Connections 
Stereotype implementationClass 
Field Summary  
protected 
charGlobalState  
Global State of the Component ConnexionMngt 
NbConnectionSupported  
Global number of connections Int
NbLocalConnection  
Number of connections opened by the local Client to a remote  Server Int
NbRemoteConnection  
Number of connections opened by a remote Client to the local  Server Int
Constructor Summary  
CconnexionMngt (TConfigureObject * lnkConfigureObject)
Constructor : Create internal obj ect , initialize to 0 variables. 
Method Summary  
m_EventOnSocket (void )
wake-up int
m_IsConnectionAuthorized (unsigned long IPAddress)
Return true if new connection is authorized bool
m_ReceiveData (TItemConnexion * lnkConnexion)
Interface with CTCPConnexion::write method for reading data from network 
return negative value if problem int
m_Reset(void )
Method for Resetting ConnectionMngt component return true if Reset bool
m_SendData (TItemConnexion * lnkConnexion)
Interface with CTCPConnexion::read method for sending data to the network Return negative value if problem int
m_Start(void )
Method for Starting ConnectionMngt co mponent return true if  Started bool
m_Stop(void )
Method for Stopping component return true if  Stopped boolModbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 46/46Modbus Organization     
April 26,  2012 http://www.modbus.org  1/50 
MODBUS APPLICATION PROTOCOL SPECIFICATION  
V1.1b 3 
 
CONTENTS  
1 Introduction  ................................ ................................ ................................ ......................  2 
1.1 Scope of this document  ................................ ................................ ...........................  2 
2 Abbreviations  ................................ ................................ ................................ ...................  2 
3 Context  ................................ ................................ ................................ .............................  3 
4 General description  ................................ ................................ ................................ ..........  3 
4.1 Protocol description  ................................ ................................ ................................ . 3 
4.2 Data Encoding  ................................ ................................ ................................ .........  5 
4.3 MODBUS Data model  ................................ ................................ ..............................  6 
4.4 MODBUS Addressing model  ................................ ................................ ....................  7 
4.5 Define MODBUS Transaction  ................................ ................................ ..................  8 
5 Function Code Categories  ................................ ................................ ..............................  10 
5.1 Public Function Code Definition  ................................ ................................ .............  11 
6 Function codes descriptions  ................................ ................................ ...........................  11 
6.1 01 (0x01) Read Coils  ................................ ................................ .............................  11 
6.2 02 (0x02) Read Discrete Inputs  ................................ ................................ .............  12 
6.3 03 (0x03) Read Holding Registers  ................................ ................................ .........  15 
6.4 04 (0x04) Read Input Registers  ................................ ................................ .............  16 
6.5 05 (0x05) Write Single Coil  ................................ ................................ ....................  17 
6.6 06 (0x06) Write Single Register  ................................ ................................ .............  19 
6.7 07 (0x07) Read Exception Status (Serial Line only)  ................................ ...............  20 
6.8 08 (0x08) Diagnostics (Serial Line only)  ................................ ................................  21 
6.8.1  Sub-function codes supported by the serial line devices  ............................  22 
6.8.2  Example and state diagram  ................................ ................................ .......  24 
6.9 11 (0x0B) Get C omm Event Counter (Serial Line only)  ................................ ..........  25 
6.10 12 (0x0C) Get Comm Event Log (Serial Line only)  ................................ .................  26 
6.11 15 (0x0F) Write Multiple Coils  ................................ ................................ ................  29 
6.12 16 (0x10) Write Multiple registers  ................................ ................................ ..........  30 
6.13 17 (0x11) Report Server ID (Serial Line only)  ................................ ........................  31 
6.14 20 (0x14) Read File Record  ................................ ................................ ...................  32 
6.15 21 (0x15) Write File Record  ................................ ................................ ...................  34 
6.16 22 (0x16) Mask Write Register  ................................ ................................ ..............  36 
6.17 23 (0x17) Read/Write Multiple registers  ................................ ................................ . 38 
6.18 24 (0x18) Read FIFO Queue  ................................ ................................ .................  40 
6.19 43 ( 0x2B) Encapsulated Interface Transport  ................................ .........................  41 
6.20 43 / 13 (0x2B / 0x0D) CANo pen General Reference Request and Response 
PDU  ................................ ................................ ................................ ......................  42 
6.21 43 / 14 (0x2B / 0x0E) Read Device Identification  ................................ ...................  43 
7 MODBUS Exception Responses  ................................ ................................ .....................  47 
Annex A (Informative): MODBUS RESERVED FUNCTION CODES, SUBCODES AND 
MEI TYPES  ................................ ................................ ................................ ....................  50 
Annex B (Informat ive): CANOPEN GENERAL REFERENCE COMMAND  ..............................  50 
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26,  2012 http://www.modbus.org  2/50 1 Introduction  
1.1 Scope of this document  
MODBUS is an application layer messaging protocol, positioned at level 7 of the OSI model, 
which  provides client/server communication between devices connected on different types of 
buses or networks.  
The industry’s serial de facto standard since 1979, MOD BUS continues to enable millions of 
automation devices to communicate. Today, support for the simple and elegant structure of 
MODBUS continues to grow. The Internet community can access MODBUS at  a reserved 
system port 502 on the TCP/IP stack.   
MODBUS is a request/reply protocol and offers services specified by function codes .  
MODBUS function codes are elements of MODBUS request/reply PDUs. The objective of this 
document is to describe the function codes used within the framework of MODBUS 
trans actions.  
 
MODBUS is an application layer messaging protocol for client/server communication between 
devices connected on different types of buses or networks.  
It is currently implemented using:  
 TCP/IP over Ethernet. See MODBUS Messaging Implementation G uide V1.0a.  
 Asynchronous serial transmission over a variety of media (wire : EIA/TIA -232-E, EIA -422, 
EIA/TIA -485-A; fiber, radio, etc.)  
 MODBUS PLUS, a high speed token passing network.  
 
TCPModbus on TCPMODBUS APPLICATION LAYER
IP
Ethernet
Physical layerEthernet II /802.3
EIA/TIA-232 or
EIA/TIA-485Master / Slave
Physical layerMODBUS+ / HDLC
OtherOther
 
Figure 1: MODBUS  communication stack  
 
 
References  
1. RFC 791, Internet Protocol, Sep81 DARPA  
2 Abbreviations  
ADU  Application Data Unit  
HDLC  High level Data Link Control  
HMI Human Machine Interface  
IETF  Internet Engineering Task Force  
I/O Input/Output  
IP Internet Protocol   
MAC  Medi a Access Control   
MB MODBUS Protocol  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  3/50 MBAP  MODBUS Application Protocol  
PDU  Protocol Data Unit  
PLC  Programmable Logic Controller  
TCP  Trans mission  Control Protocol  
3 Context  
The MODBUS protocol allows an easy communication within all types of network 
archi tectures.  
 
 
 
Figure 2: Example of MODBUS Network Architecture  
 
Every type of devices (PLC, HMI, Control Panel, Driver, Motion control, I/O Device…) can use 
MODBUS protocol to initiate a remote operation.  
The same communication can be done as well on serial line as on an Ethernet TCP/IP 
networks.  Gateways allow a communication between several types of buses or network using 
the MODBUS protocol.  
 
4 General description  
4.1 Protocol description  
The MODBUS protocol defines a simple protoc ol data unit (PDU)  independent of the 
underlying communication layers. The mapping of MODBUS protocol on specific buses or 
network can introduce some additional fields on the application data unit (ADU) .  
 
Additional address Function code Data Error checkADU
PDU
Figure 3: General MODBUS frame  
PL C PL C HMI I/ O I/ OI/ ODrive
MODBUS ON TCP/IP
Gateway Gateway Gateway
MODBUS ON MB+MODBUS ON RS232
MODBUS ON RS485 DeviceHMIPL CPL C
Drive
I/ OI/ OI/ O
I/ O
DeviceMODBUS COMMUNICATIONMODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  4/50  
The MODBUS application data unit is built by the client that initiates a MODBUS transaction. 
The function indicates to the server what kind of action to perform. The MODBUS application 
protocol establishes th e format of a request initiated by a client.  
The function code field of a MODBUS data unit is coded in one byte. Valid codes are in the 
range of 1 ... 255 decimal ( the range 128 – 255 is reserved and used for exception 
responses). When a message is sent f rom a Client to a Server device the function code field 
tells the server what kind of action to perform.  Function code "0" is not valid.  
Sub-function codes are added to some function codes  to define multiple actions.  
The data field of messages sent from a client to server devices contains additional information 
that the server uses to take the action defined by the function code. This can include items 
like discrete and register addresses, the quantity of items to be handled, and the count of 
actual data bytes in the field.  
The data field may be nonexistent (of zero length) in certain kinds of requests, in this case the 
server does not require any additional information. The function code alone specifies the 
action.  
If no error occurs related to the MODBUS  function requested in a properly received MODBUS 
ADU the data field of a response from a server to a client contains the data requested. If an 
error related to the MODBUS function requested occurs, the field contains an exception code 
that the server appl ication can use to determine the next action to be taken.  
For example a client can read the ON / OFF states of a group of discrete outputs or inputs or 
it can read/write the data contents of a group of registers.  
When the server responds to the client, it uses the function code field to indicate either a 
normal (error -free) response or that some kind of error occurred (called an exception 
response). For a normal response, the server simply echoes to the request the original 
function code.  
 
 
 
Function code  Data Request  Client  Server  
Initiate request  
Perform the action 
Initiate the response  
Receive the response  Function code  Data Response  
 
Figure 4: MODBUS transaction (error free)  
For an exception response, the server returns a code that is equivalent to the original function 
code from the request PDU with its most significant bit set to logic 1.  
 
 
Figure  5: MODBUS transaction (exception response)  
Client Server
Initiate request
Error detected in the action
Initiate an error
Exception Function code Receive the responseException codeFunction code Data RequestMODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  5/50  
 Note : It is desirable to manage a time out in order not to indefinitely wait for an answer which will perhaps 
never arrive.  
 
The size of the MODBUS PDU is limited by the size constraint inherited from the first 
MODBUS implementation on Serial Line network (max. RS485 ADU = 256 bytes).  
Therefore:  
MODBUS  PDU for serial line communication =  256 - Server address (1 byte) - CRC (2 
bytes) =  253 bytes . 
 
Consequently:  
RS232 / RS485 ADU   = 253 bytes + Server address (1 byte) + CRC (2 bytes) = 256 bytes . 
TCP MODBUS ADU  = 253 bytes + MBAP (7 bytes) = 260 bytes . 
 
The MODBUS protocol defines three PDUs. They are :  
 
 MODBUS Request PDU, mb_req_pdu  
 MODBUS Response PDU, mb_rsp_pdu  
 MODBUS Excepti on Response PDU, mb_excep_rsp_pdu  
 
The mb_req_pdu is defined as:  
 
mb_req_pdu = {function_code, request_data},      where  
function_code = [1 byte] MODBUS function code,  
request_data = [n bytes] This field is function code dependent and usually  
                        contains information such as variable references,  
                                               variable counts, data offsets, sub -function codes etc.  
 
The mb_rsp_pdu is defined as:  
 mb_rsp_pdu = {function_code, response_data},      where  
function_code = [1 byte] MODBUS function code  
response_data = [n bytes] This field is function code dependent and usually  
                          contains information such as variable references,  
                                                 variable counts, data offsets, sub -function codes, etc.  
 
The mb_excep_rsp_pdu is defined as:  
     mb_excep_rsp_pdu = { exception -function_code, request_data},      where  
exception -function_code = [1 byte] MODBUS function code + 0x80  
exception_code = [1 byte] MODBUS Exception Code Defined in table  
                                "MODBUS Exception Codes" (see section 7 ). 
 
4.2 Data Encoding  
 MODBUS uses a ‘big -Endian’ representation fo r addresses and data items. This means 
that when a numerical quantity larger than a single byte is transmitted, the most significant 
byte is sent first. So for example  
 
 Register size  value  
 16 - bits 0x1234   the first byte sent is  0x12  then 0x34  
 
 Note : For more details, see [1] .  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  6/50  
4.3 MODBUS Data model  
MODBUS bases its data model on a series of tables that have distinguishing characteristics. 
The four primary tables are:  
 
Primary tables  Object type  Type of 
access  Comments  
 Discretes Input  Single bit  Read -Only  This type of data can be provided by an I/O system.  
Coils  Single bit  Read -Write  This type of data can be alterable by an application 
program.  
Input Registers  16-bit word  Read -Only  This type of data can be provided by an I/O system  
Holding Registers  16-bit word  Read -Write  This type of data can be alterable by an application 
program.  
 
The distinctions between inputs and outputs, and between bit -addressable and word -
addressable data items, do not imply any application behavior. It is perfectly acceptable, and 
very common, to regard all four tables as overlaying one another, if this is the most natural 
interpretation on the target machine in question.  
For each of the primary tables, the protocol allows individual selection of 65536 data  items, 
and the operations of read or write of those items are designed to span multiple consecutive 
data items up to a data size limit which is dependent on the transaction function code.  
It’s obvious that all the data handled via MODBUS (bits, registers)  must be located in device 
application memory. But physical address in memory should not be confused with data 
reference. The only requirement is to link data reference with physical address.  
MODBUS logical reference numbers, which are used in MODBUS funct ions, are unsigned 
integer indices starting at zero.  
 
 Implementation examples of MODBUS model  
The examples below show two ways of organizing the data in device. There are different 
organizations possible, but not all are described in this document. Each de vice can have its 
own organization of the data according to its application  
 
Example 1 : Device having 4 separate blocks  
The example below shows data organization in a device having digital and analog, inputs and 
outputs. Each block is separate because dat a from different blocks have no correlation. Each 
block is thus accessible with different MODBUS functions.  
 
Input DiscreteMODBUS accessDevice application memory
MODBUS SERVER DEVICEMODBUS Request Coils
Input Registers
Holding
Registers
 
Figure 6 MODBUS Data Model with separate block  
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  7/50 Example 2: Device having only 1 block  
In this example, the device has only 1 data block. The same data can be reached via several 
MODBUS functions, either via a 16 bit access or via an access bit.  
 
Device application memory
MODBUS SERVER DEVICEMODBUS RequestInput DiscreteMODBUS access
Coils
Input Registers
Holding
RegistersR
W
R
W
 
Figure 7 MODBUS Data Model with only 1 block  
 
 
4.4 MODB US Addressing model  
 
The MODBUS application protocol defines precisely PDU addressing rules.  
In a MODBUS PDU each data is addressed from 0 to 65535.  
It also defines clearly a MODBUS data model composed of 4 blocks that comprises several 
elements numbered from 1 to n.   
In the MODBUS data Model each element within a data block is numbered from 1 to n.  
Afterwards the MODBUS data model has to be bound to the device application ( IEC -61131 
object, or other application model).  
The pre -mapping between the MODBU S data model and the device application is totally 
vendor device specific.  
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  8/50  
Figure 8 MODBUS Addressing model  
 
The previous figure shows that a MODBUS data numbered X is addressed in the MODBUS 
PDU X -1.  
 
 
4.5 Define MODBUS Transaction  
The following state diagram describes the generic processing of a MODBUS transaction in 
server side.  
Discrete Input
Coils
Input Registers
Holding RegistersMODBUS data modelDevice application
1
.
.
.
1
.
5
.
1
2
. MODBUS PDU addresses
1
.
.
55Read Registers 54Read Registers 1Read coils 4Read input 0
MODBUS Standard Application specificMappingMODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  9/50 
V 
Validate function  
code 
Validate data  
value  
ExceptionCode = 3  Wait for a MB  
indication  
ExceptionCode = 2  ExeptionCode = 1  
Send Modbus  
Exception  
Response  ExceptionCode = 4, 5, 6  Execute MB  
function  
Send Modbus  
Response  Validate data  
Address  
[invalid]  [invalid]  
[invalid]  
[valid]  
[invalid]  [valid] 
[valid]  
[valid] [Receive MB indication]   
Figure 9 MODBUS Transaction state diagram  
 
Once the request has been processed by a server, a MODBUS response using the 
adequate MODBUS server transaction is built.  
Depending on the result of the processing two types of response are built :  
 A positive MODBUS response :  
 the response function code = the request function code  
 
 A MODBUS Exce ption response ( see section 7 ): 
 the objective is to provide to the client relevant information concerning the 
error detected during the processing ;  
 the exception function code = the request function code + 0x80 ;  
 an exception code is provided to indicate the reason of the error.  
  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  10/50 5 Function Code Categories  
 
There are three categories of MODBUS Functions codes. They are :  
 
Public Function Codes  
 Are well defined fun ction codes ,  
 guaranteed to be unique,  
 validated by the MODBUS.org community,  
 publicly documented  
 have available conformance test,  
 includes both defined public assigned function codes as well as unassigned function 
codes reserved for future use.  
User -Defined Function Codes  
 there are two ranges of user -defined function codes, i.e. 65  to 72 and from 100 to 110 
decimal.  
 user can select and implement a function code that is not supported by the 
specification.  
 there is no guarantee that the use of the selected function code will be unique  
 if the user wants to re -position the functionality as a public function code, he must 
initiate an RFC to introduce the change into the public category and to have a new 
public function code assigned.  
 MODBUS Organizatio n, Inc expressly reserves the right to develop the proposed RFC.  
Reserved Function Codes  
 Function Codes currently used by some companies for legacy products and  that 
are not available for public use.  
 Informative Note:  The reader is asked refer to Annex A  (Informative) MODBUS 
RESERVED FUNCTION CODES, SUBCODES AND MEI TYPES.  
 
Figure 10 MODBUS Function Code Categories  
 
 
       User Defined Function codes
165100110
72   User Defined Function codes
PUBLIC function codesPUBLIC function codesPUBLIC function codes127MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  11/50 5.1 Public Function Code Definition  
 
    Function Codes    
code  Sub 
code  (hex)  Section  
Data 
Access  Bit 
access  Physical Discrete 
Inputs  Read  Discrete Inputs  02  02 6.2 
Internal Bits  
 Or 
 Physical coils  Read Coils  01  01 6.1 
Write Single Coil  05  05 6.5 
Write Multiple Coils  15  0F 6.11  
     
16 bits 
access  Physical Input 
Registers  Read Input Register  04  04 6.4 
Internal Registers  
 Or 
Physical Output 
Registers  Read Holding Registers  03  03 6.3 
Write Single Register  06  06 6.6 
Write Multiple Registers  16  10 6.12  
Read/Write Multiple Registers  23  17 6.17  
Mask Write Register  22  16 6.16  
Read FIFO queue  24  18 6.18  
File record access  Read File record  20  14 6.14  
Write File record  21  15 6.15  
 
 
Diagnostics  Read Exception status  07  07 6.7 
Diagnostic  08 00-18,20  08 6.8 
Get Com event counter  11  OB 6.9 
Get Com Event Log  12  0C 6.10  
Report Server  ID 17  11 6.13  
Read device Identification  43 14 2B 6.21  
Other  Encapsulated Interface 
Transport  43 13,14  2B 6.19  
 CANopen General Reference  43 13 2B 6.20  
 
 
6 Function codes descriptions  
6.1 01 (0x01) Read Coils  
This function code is used to read from 1 to 2000 contiguous status of coils in a remote 
device. The Request PDU specifies the starting address, i.e. the address of the first coil 
specified, and the number of coils. In the PDU Coils are addressed starting  at zero. Therefore 
coils numbered 1 -16 are addressed as 0 -15. 
The coils in the response message are packed as one coil per bit of the data field. Status is 
indicated as 1= ON and 0= OFF. The LSB of the first data byte contains the output addressed 
in the query. The other coils follow toward the high order end of this byte, and from low order 
to high order in subsequent bytes.  
If the returned output quantity is not a multiple of eight, the remaining bits in the final data 
byte will be padded with zeros (to ward the high order end of the byte). The Byte Count field 
specifies the quantity of complete bytes of data.  
 
Request  
Function code  1 Byte  0x01  
Starting Address  2 Bytes  0x0000 to 0xFFFF  
Quantity of coils  2 Bytes  1 to 2000 (0x7D0)  
 
Response  
Function code  1 Byte  0x01  
Byte count  1 Byte  N* 
Coil Status  n  Byte  n = N or N+1  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  12/50 *N = Quantity of Outputs / 8, if the remainder is different of 0  N = N+1  
Error  
Function  code  1 Byte  Function code + 0x80  
Exception code  1 Byte  01 or 02 or 03 or 04  
 
 
Here is  an example of a request to read discrete outputs 20 –38: 
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  01 Function  01 
Starting Address Hi  00 Byte Count  03 
Starting Address Lo  13 Outputs status 27 -20 CD 
Quantity of Outputs Hi  00 Outputs status 35 -28 6B 
Quantity of Outputs Lo  13 Outputs status 38 -36 05 
 
The status of outputs 27 –20 is shown as the byte value CD hex, or binary 1100 1101. Output 
27 is the MSB of this byte, and output 20 is the LSB.  
By convention, bits within a byte are shown with the MSB to the left, and the LSB to the right. 
Thus the outputs in the first byte are ‘27 through 20’, from left to right. The next byte has 
outputs ‘35 through 28’, left to right. As the bits are transmitted serially, they flow from LSB to 
MSB:  20 . . . 27, 28 . . . 35, and so on.  
In the last data byte, the status of outputs 38 -36 is shown as the byte value 05 hex, or binary 
0000 0101. Output 38 is in the sixth bit position from the left, and output 36 is the LSB of this 
byte. The five remaining  high order bits are zero filled.  
 Note : The five remaining bits (toward the high order end) are zero filled.  
 
MB Server Sends mb_exception_rsp EXITMB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NO
ExceptionCode = 02YESNO
ExceptionCode =  03YESENTRY
ReadDiscreteOutputs  == OK
MB Server Sends mb_rspNO
YES0x0001  Quantity of Outputs  0x07D0Function code
supported
Starting Address == OK
AND
Starting Address + Quantity of Outputs == OK
ExceptionCode =  04Request Processing
 
Figure 11: Read Coils state diagram  
 
6.2 02 (0x02) Read Discrete Inputs  
This function code is used to read from 1 to 2000 contiguous status of discrete inputs in a 
remote device. The Request PDU specifies the starting address, i.e. the address of the first MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  13/50 input specified, and the number of inputs. In the PDU Discrete Inputs a re addressed starting 
at zero. Therefore Discrete inputs numbered 1 -16 are addressed as 0 -15. 
The discrete inputs in the response message are packed as one input per bit of the data field. 
Status is indicated as 1= ON; 0=  OFF. The LSB of the first data byt e contains the input 
addressed in the query. The other inputs follow toward the high order end of this byte, and 
from low order to high order in subsequent bytes.  
If the returned input quantity is not a multiple of eight, the remaining bits in the final d ata byte 
will be padded with zeros (toward the high order end of the byte). The Byte Count field 
specifies the quantity of complete bytes of data.  
 
Request  
Function code  1 Byte  0x02  
Starting Address  2 Bytes  0x0000 to 0xFFFF  
Quantity of Inputs  2 Bytes  1 to 2000 (0x7D0)  
 
Response  
Function code  1 Byte  0x02  
Byte count  1 Byte  N* 
Input Status  N* x 1 Byte   
*N = Quantity of Inputs / 8 if the remainder is different of 0  N = N+1  
Error  
Error code  1 Byte  0x82  
Exception code  1 Byte  01 or 02 or 03 or 04  
 
Here is an example of a request to read discrete inputs 197 – 218:  
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  02 Function  02 
Starting Address Hi  00 Byte Count  03 
Starting Address Lo  C4 Inputs Status 204 -197 AC 
Quantity of Inputs Hi  00 Inputs Status 212 -205 DB 
Quantity of Inputs Lo  16 Inputs Status 218 -213 35 
 
The status of discrete inputs 204 –197 is shown as the byte value AC hex, or binary 1010 
1100. Input 204 is the MSB of this byte, and input 197 is the LSB.  
The status of discrete  inputs 218 –213 is shown as the byte value 35 hex, or binary 0011 0101. 
Input 218 is in the third bit position from the left, and input 213 is the LSB.  
 Note : The two remaining bits (toward the high order end) are zero filled.  
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  14/50 
MB Server Sends mb_exception_rsp EXITMB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NO
ExceptionCode = 02YESNO
ExceptionCode =  03YESENTRY
ReadDiscreteInputs  == OK
MB Server Sends mb_rspNO
YES0x0001  Quantity of Inputs  0x07D0Function code
supported
Starting Address == OK
AND
Starting Address + Quantity of Inputs == OK
ExceptionCode =  04Request Processing 
Figure 12: Read Discrete Inputs s tate diagram  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  15/50 6.3 03 (0x03) Read Holding Registers  
This function code is used to read the contents of a contiguous block of holding registers in a 
remote device. The Request PDU specifies the starting r egister address and the number of 
registers. In the PDU Registers are addressed starting at zero. Therefore registers numbered 
1-16 are addressed as 0 -15. 
The register data in the response message are packed as two bytes per register, with the 
binary contents right justified within each byte. For each register, the first byte contains the 
high order bits and the second contains the low order bits.  
 
Request  
Function code  1 Byte  0x03  
Starting Address  2 Bytes  0x0000 to 0xFFFF  
Quantity of Registers  2 By tes 1 to 125 (0x7D)  
 
Response  
Function code  1 Byte  0x03  
Byte count  1 Byte  2 x N* 
Register value  N* x 2 Bytes   
*N = Quantity of Registers  
Error  
Error code  1 Byte  0x83  
Exception code  1 Byte  01 or 02 or 03 or 04  
 
 
Here is an example of a request to read registers 108 – 110:  
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  03 Function  03 
Starting Address Hi  00 Byte Count  06 
Starting Address Lo  6B Register value Hi (108)  02 
No. of Registers Hi  00 Register value Lo (108)  2B 
No. of Registers Lo  03 Register value Hi (109)  00 
  Register value Lo (109)  00 
  Register value Hi (110)  00 
  Register value Lo (110)  64 
 
The contents of register 108 are shown as the two byte values of 02 2B hex,  or 555 decimal. 
The contents of registers 109 –110 are 00 00 and 00 64 hex, or 0 and 100 decimal, 
respectively.  
  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  16/50 
MB Server Sends mb_exception_rsp EXITMB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NO
ExceptionCode = 02YESNO
ExceptionCode =  03YESENTRY
ReadMultipleRegisters  == OK
MB Server Sends mb_rspNO
YES0x0001  Quantity of Registers  0x007DFunction code
supported
Starting Address == OK
AND
Starting Address + Quantity of Registers == OK
ExceptionCode =  04Request Processing 
Figure 13: Read Holding Registers state diagram  
 
 
6.4 04 (0x04) Read Input Registers  
This function code is used to read from 1 to 125 contiguous input registers in a remote device. 
The Request PDU specifies the starting register address and the number of registers. In the 
PDU Registers are addressed starting at zero. Therefore input registers n umbered 1 -16 are 
addressed as 0 -15. 
The register data in the response message are packed as two bytes per register, with the 
binary contents right justified within each byte. For each register, the first byte contains the 
high order bits and the second contains the low order bits.  
Request  
Function code  1 Byte  0x04  
Starting Address  2 Bytes  0x0000 to 0xFFFF  
Quantity of Input Registers  2 Bytes  0x0001 to 0x007D  
 
Response  
Function code  1 Byte  0x04  
Byte count  1 Byte  2 x N* 
Input Registers  N* x 2 Bytes   
*N = Quantity of Input Registers  
 
Error  
Error code  1 Byte  0x84  
Exception code  1 Byte  01 or 02 or 03 or 04  
 
Here is an example of a request to read input register 9:  
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  04 Function  04 
Starting  Address Hi  00 Byte Count  02 
Starting Address Lo  08 Input Reg. 9 Hi  00 
Quantity of Input Reg. Hi  00 Input Reg. 9 Lo  0A MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  17/50 Quantity of Input Reg. Lo  01   
 
The contents of input register 9 are shown as the two byte values of 00 0A hex, or 10 decimal.  
 
MB Server Sends mb_exception_rsp EXITMB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NO
ExceptionCode = 02YESNO
ExceptionCode =  03YESENTRY
ReadInputRegisters  == OK
MB Server Sends mb_rspNO
YES0x0001  Quantity of Registers  0x007DFunction code
supported
Starting Address == OK
AND
Starting Address + Quantity of Registers == OK
ExceptionCode =  04Request Processing
 
Figure 14: Read Input Registers state diagram  
 
 
 
 
 
 
6.5 05 (0x05) Write Single Coil  
This function code is used to write a single output to either ON or OFF in a remote device.  
The requested ON/OFF state is specified by a constant in the request data field. A value of FF 
00 hex requests the output to be ON. A value of 00 00 requests it to be OFF. All other values 
are illegal and will not affect the output.  
The Request PDU specifi es the address of the coil to be forced. Coils are addressed starting 
at zero. Therefore coil numbered 1 is addressed as 0. The requested ON/OFF state is 
specified by a constant in the Coil Value field. A value of 0XFF00 requests the coil to be ON. 
A value  of 0X0000 requests the coil to be off. All other values are illegal and will not affect the 
coil.  
 
The normal response is an echo of the request, returned after the coil state has been written.  
Request  
Function code  1 Byte  0x05  
Output Address  2 Bytes  0x0000 to 0xFFFF  
Output Value  2 Bytes  0x0000 or 0xFF00  
 
Response  
Function code  1 Byte  0x05  
Output Address  2 Bytes  0x0000 to 0xFFFF  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  18/50 Output Value  2 Bytes  0x0000 or 0xFF00  
 
Error  
Error code  1 Byte  0x85  
Exception code  1 Byte  01 or 02 or 03 or 04  
 
 
Here is an example of a request to write Coil 173 ON:  
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  05 Function  05 
Output Address Hi  00 Output Address Hi  00 
Output Address Lo  AC Output Address Lo  AC 
Output Value Hi  FF Output Value Hi  FF 
Output Value Lo  00 Output Value Lo  00 
 
  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  19/50 
MB Server Sends mb_exception_rsp EXITExceptionCode =  04MB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NO
ExceptionCode = 02YESNO
ExceptionCode =  03YESENTRY
WriteSingleOutput  == OK
MB Server Sends mb_rspNO
YESOutput Value == 0x0000
OR 0xFF00Function code
supported
Output Address == OK
Request Processing 
Figure 15: Write Single Output state diagram  
 
6.6 06 (0x06) Write Single Register  
This function code is used to write a single holding register in a remote device.  
The Request PDU specifies the address of the register to be written. Registers are addressed 
starting at zero. Therefore register numbered 1 is addressed as 0.  
The normal response is an echo of the request, returned after the register contents have been 
written.  
 
Request  
Function code  1 Byte  0x06  
Register Address  2 Bytes  0x0000 to 0xFFFF  
Register Value  2 Bytes  0x0000 to  0xFFFF  
 
Response  
Function code  1 Byte  0x06  
Register Address  2 Bytes  0x0000 to 0xFFFF  
Register Value  2 Bytes  0x0000 to  0xFFFF  
 
Error  
Error code  1 Byte  0x86  
Exception code  1 Byte  01 or 02 or 03 or 04  
 
Here is an example of a request to write register 2 to 00 03 hex:  
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  06 Function  06 
Register Address Hi  00 Register Address Hi 00 
Register Address Lo  01 Register Address Lo  01 
Register Value Hi  00 Register Value Hi  00 
Register Value Lo  03 Register Value Lo  03 
 
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  20/50 
MB Server Sends mb_exception_rsp EXITExceptionCode =  04MB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NO
ExceptionCode = 02YESNO
ExceptionCode =  03YESENTRY
WriteSingleRegister  == OK
MB Server Sends mb_rspNO
YES0x0000  Register   Value  0xFFFFFunction code
supported
Register Address  == OK
Request Processing 
Figure 16: Write Single Register state diagram  
 
 
 
 
6.7  07 (0x07) Read Exception Status (Serial Line only)  
This function code is used to read the contents of eight Exception Status outputs in a remote 
device.  
The function provides a simple method for accessing this information,  because the Exception 
Output references are known (no output reference is needed in the function).  
The normal response contains the status of the eight Exception Status outputs. The outputs 
are packed into one data byte, with one bit per output. The statu s of the lowest output 
reference is contained in the least significant bit of the byte.  
The contents of the eight Exception Status outputs are device specific.  
Request  
Function code  1 Byte  0x07  
 
Response  
Function code  1 Byte  0x07  
Output Data  1 Byte  0x00 to 0xFF  
 
Error  
Error code  1 Byte  0x87  
Exception code  1 Byte  01 or 04  
 
Here is an example of a request to read the exception status:  
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  07 Function  07 
  Output Data  6D 
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  21/50 In this example, the output data is 6D hex (0110 1101 binary). Left to right, the outputs are 
OFF –ON–ON–OFF –ON–ON–OFF –ON. The status is shown from the highest to the lowest 
addressed output.  
MB Server Sends mb_exception_rspEXITExceptionCode =  04MB Server receives mb_req_pdu
ExceptionCode = 01NO
YESENTRY
ReadExceptionStatus == OK
MB Server Sends mb_rspNO
YESFunction code
supported
Request Processing
 
 
Figure 17: Read Exception Status state diagram  
 
 
 
 
6.8 08 (0x08) Diagnostics (Serial Line only)  
MODBUS function code 08 provides a series of tests for checking the communication system 
between a client device and a server, or for checking various internal error conditions within a 
server.  
The function uses a two –byte sub -function code field in the q uery to define the type of test to 
be performed. The server echoes both the function code and sub -function code in a normal 
response. Some of the diagnostics cause data to be returned from the remote device in the 
data field of a normal response.  
In genera l, issuing a diagnostic function to a remote device does not affect the running of the 
user program in the remote device. User logic, like discrete and registers, is not accessed by 
the diagnostics. Certain functions can optionally reset error counters in the remote device.  
A server device can, however, be forced into ‘Listen Only Mode’ in which it will monitor the 
messages on the communications system but not respond to them. This can affect the 
outcome of your application program if it depends upon any fu rther exchange of data with the 
remote device. Generally, the mode is forced to remove a malfunctioning remote device from 
the communications system.  
 
The following diagnostic functions are dedicated to serial line devices.  
 
The normal response to the Retu rn Query Data request is to loopback the same data. The 
function code and sub -function codes are also echoed.  
Request  
Function code  1 Byte  0x08  
Sub-function  2 Bytes   
Data  N x 2 Bytes   MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  22/50  
Response  
Function code  1 Byte  0x08  
Sub-function  2 Bytes   
Data  N x 2 Bytes   
 
Error  
Error code  1 Byte  0x88  
Exception code  1 Byte  01 or 03 or 04  
 
6.8.1  Sub-function codes supported by the serial line devices  
Here the list of sub -function codes supported by the serial line devices. Each sub -function 
code is then listed with an example of the data field contents that would apply for that 
diagnostic.  
 
Sub-function code  Name  
Hex Dec 
00 00 Return Query Data  
01 01 Restart Communications Option  
02 02 Return Diagnostic Register  
03 03 Change ASCII Input Delimiter  
04 04 Force Listen Only Mode  
 05.. 09  RESERVED  
0A 10 Clear Counters and Diagnostic Register  
0B 11 Return Bus Message Count  
0C 12 Return Bus Communication Error Count  
0D 13 Return Bus Exception Error Count  
0E 14 Return Server  Message Count  
0F 15 Return Server  No Response Count  
10 16 Return Server  NAK Count  
11 17 Return Server  Busy Count  
12 18 Return Bus Character Overrun Count  
13 19 RESERVED  
14 20 Clear Overrun Counter and Flag  
N.A.  21 ... 65535  RESERVED  
 
00 Return Query Data  
The data passed in the request data field is to be returned (looped back) in the response. The 
entire response message should be identical to the request.  
Sub-function  Data Field (Request)  Data Field (Response)  
00 00  Any Echo Request Data  
 
01 Restart Communications Option  
The remote device serial line port must be initialized and restarted, and all of its 
communications event counters are cleared. If the port is currently in Listen Only Mode, no 
response is returned. This function is the only one that brings the port out of Lis ten Only 
Mode. If the port is not currently in Listen Only Mode, a normal response is returned. This 
occurs before the restart is executed.  
When the remote device receives the request, it attempts a restart and executes its power –up 
confidence tests. Succe ssful completion of the tests will bring the port online.  
A request data field contents of FF 00 hex causes the port’s Communications Event Log to be 
cleared also. Contents of 00 00 leave the log as it was prior to the restart.  
Sub-function  Data Field (Req uest)  Data Field (Response)  
00 01  00 00  Echo Request Data  
00 01  FF 00  Echo Request Data  
 
02 Return Diagnostic Register  
The contents of the remote device’s 16 –bit diagnostic register are returned in the response.  
Sub-function  Data Field (Request)  Data Field  (Response)  
 00 02  00 00  Diagnostic Register Contents  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  23/50  
03 Change ASCII Input Delimiter  
The character ‘CHAR’ passed in the request data field becomes the end of message delimiter 
for future messages (replacing the default LF character). This function is useful in cases of a 
Line Feed is not required at the end of ASCII messages.  
Sub-function  Data Field (Request)  Data Field (Response)  
00 03  CHAR 00  Echo Request Data  
 
04 Force Listen Only Mode  
Forces the addressed remote device to its Listen Only Mode for M ODBUS communications. 
This isolates it from the other devices on the network, allowing them to continue 
communicating without interruption from the addressed remote device. No response is 
returned.  
When the remote device enters its Listen Only Mode, all ac tive communication controls are 
turned off. The Ready watchdog timer is allowed to expire, locking the controls off.  While the 
device is in this mode, any MODBUS messages addressed to it or broadcast are monitored, 
but no actions will be taken and no resp onses will be sent.  
The only function that will be processed after the mode is entered will be the Restart 
Communications Option function (function code 8, sub -function 1).  
Sub-function  Data Field (Request)  Data Field (Response)  
00 04  00 00  No Response Returned  
 
10 (0A Hex) Clear Counters and Diagnostic Register  
The goal is to clear all counters and the diagnostic register. Counters are also cleared upon 
power –up. 
Sub-function  Data Field (Request)  Data Field (Response)  
00 0A  00 00  Echo Request Data  
 
11 (0B Hex) Return Bus Message Count  
The response data field returns the quantity of messages that the remote device has detected 
on the communications system since its last restart, clear counters operation, or power –up. 
Sub-function  Data Field (Request)  Data  Field (Response)  
00 0B  00 00  Total Message Count  
 
12 (0C Hex) Return Bus Communication Error Count  
The response data field returns the quantity of CRC errors encountered by the remote device 
since its last restart, clear counters operation, or power –up. 
Sub-function  Data Field (Request)  Data Field (Response)  
00 0C  00 00  CRC Error Count  
 
13 (0D Hex) Return Bus Exception Error Count  
The response data field returns the quantity of MODBUS exception responses returned by the 
remote device since its last restart , clear counters operation, or power –up. 
Exception responses are described and listed in section 7 . 
Sub-function  Data Field (Request)  Data Field (Response)  
00 0D  00 00 Exception Error Count  
14 (0E Hex) Return Server  Message Count  
The response data field returns the quantity of messages addressed to the remote device, or 
broadcast, that the remote device has processed since its last restart, clear counters 
operation, or power –up. 
Sub-function  Data Field (Request)  Data Field (Response)  
00 0E  00 00  Server  Message Count  
 
15 (0F Hex) Return Server  No Response Count  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  24/50 The response data field returns the quantity of messages addressed to the remote device for 
which it has returned no response (neither a normal response nor an exception response), 
since its last restart, clear counters operation, or power –up. 
Sub-function  Data Field (Request)  Data Field (Response)  
00 0F  00 00  Server  No Response Count  
 
16 (10 Hex) Return Serv er NAK Count  
The response data field returns the quantity of messages addressed to the remote device for 
which it returned a Negative Acknowledge (NAK) exception response, since its last restart, 
clear counters operation, or power –up. Exception responses a re described and listed in 
section 7 . 
Sub-function  Data Field (Request)  Data Field (Response)  
00 10  00 00  Server  NAK Count  
 
17 (11 Hex) Return Server  Busy Count  
The response data field returns the quantity of messages addressed to the remote device for 
which it returned a Server  Device Busy exception response, since its last restart, clear 
counters operation, or power –up.  
Sub-function  Data Field (Request)  Data Field  (Response)  
00 11  00 00  Server  Device Busy Count  
 
18 (12 Hex) Return Bus Character Overrun Count  
The response data field returns the quantity of messages addressed to the remote device that 
it could not handle due to a character overrun condition, since it s last restart, clear counters 
operation, or power –up. A character overrun is caused by data characters arriving at the port 
faster than they can be stored, or by the loss of a character due to a hardware malfunction.  
Sub-function  Data Field (Request)  Data  Field (Response)  
00 12  00 00  Server  Character Overrun Count  
 
20 (14 Hex) Clear Overrun Counter and Flag  
Clears the overrun error counter and reset the error flag.  
Sub-function  Data Field (Request)  Data Field (Response)  
00 14  00 00  Echo Request Data  
 
6.8.2  Example and state diagram  
Here is an example of a request to remote device to Return Query Data. This uses a sub -
function code of zero (00 00 hex in the two –byte field). The data to be returned is sent in the 
two–byte data field (A5 37 hex).  
 
Request  Resp onse  
Field Name  (Hex)  Field Name  (Hex)  
Function  08 Function  08 
Sub-function Hi  00 Sub-function Hi  00 
Sub-function Lo  00 Sub-function Lo  00 
Data Hi  A5 Data Hi  A5 
Data Lo  37 Data Lo  37 
 
The data fields in responses to other kinds of queries could contain error counts or other data  
requested by the sub -function code.  
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  25/50 
MB Server Sends mb_exception_rspEXITExceptionCode =  04MB Server receives mb_req_pdu
ExceptionCode = 01NO
YESENTRY
Diagnostic == OK
MB Server Sends mb_rspNO
YESFunction code supported
AND
Subfunction code  supported
ExceptionCode =  03Data Value == OKNO
YES
Request Processing 
Figure 18: Diagnostic state diagram  
 
 
6.9 11 (0x0B) Get Comm Event Counter  (Serial Line only)  
This function code is used to get a status word and an event count from the remote device's 
communication event counter.  
By fetching the current count before and after a series of messages, a client can determine 
whether the messages were handled normally by the remote device.  
The device’s event counter is incremented once for each successful message completion. It is 
not incremented for exception responses, poll commands, or fetch event counter commands.  
The event counter can be reset  by means of the Diagnostics function (code 08), with a sub -
function of Restart Communications Option (code 00 01) or Clear Counters and Diagnostic 
Register (code 00 0A).  
The normal response contains a two –byte status word, and a two –byte event count. The 
status word will be all ones (FF  FF hex) if a previously –issued program command is still being 
processed by the remote device (a busy condition exists). Otherwise, the status word will be 
all zeros.  
Request  
Function code  1 Byte  0x0B  
 
Response  
Function cod e 1 Byte  0x0B  
Status  2 Bytes  0x0000 to 0xFFFF  
Event Count  2 Bytes  0x0000 to 0xFFFF  
 
Error  
Error code  1 Byte  0x8B  
Exception code  1 Byte  01 or 04  
 
Here is an example of a request to get the communications event counter in remote device:  
 
Request  Response  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  26/50 Field Name  (Hex)  Field Name  (Hex)  
Function  0B Function  0B 
  Status Hi  FF 
  Status Lo  FF 
  Event Count Hi  01 
  Event Count Lo  08 
 
In this example, the status word is FF FF  hex, indicating that a program function is still in 
progress in the remote device. The event count shows that 264 (01 08 hex) events have been 
counted by the device.  
 
MB Server Sends mb_exception_rsp EXITExceptionCode =  04MB Server receives mb_req_pdu
ExceptionCode = 01NO
YESENTRY
GetCommEventCounter == OK
MB Server Sends mb_rspNO
YESFunction code
supported
Request Processing
 
Figure 19: Get Comm Event Counter st ate diagram  
 
 
 
 
 
 
 
6.10  12 (0x0C) Get Comm Event Log (Serial Line only)  
This function code is used to get a status word, event count, message count, and a field of 
event bytes from the remote device.  
The status word and event counts are identical to that returned by the Get Communications 
Event Counter function (11, 0B hex).  
The message counter contains the quantity of messages processed by the remote device 
since its last restart, clear counters operation, or power –up. This count is identical to that 
returned by the Diagnostic function (code 08), sub -function Return Bus Message Count (code 
11, 0B hex).  
The event bytes field contains 0 -64 bytes, with each byte corresponding to the status of one 
MODBUS send or receive operation for the remote device. The rem ote device enters the 
events into the field in chronological order. Byte 0 is the most recent event. Each new byte 
flushes the oldest byte from the field.  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  27/50 The normal response contains a two –byte status word field, a two –byte event count field, a 
two–byte m essage count field, and a field containing 0 -64 bytes of events. A byte count field 
defines the total length of the data in these four fields.  
Request  
Function code  1 Byte  0x0C  
 
Response  
Function code  1 Byte  0x0C  
Byte Count  1 Byte  N* 
Status  2 Bytes  0x0000 to 0xFFFF  
Event Count  2 Bytes  0x0000 to 0xFFFF  
Message Count  2 Bytes  0x0000 to 0xFFFF  
Events  (N-6) x 1 Byte   
*N = Quantity of Events + 3 x 2 Bytes, (Length of Status, Event Count and Message Count)  
 
Error  
Error code  1 Byte  0x8C  
Exception code  1 Byte  01 or 04  
 
Here is an example of a request to get the communications event log in remote device:  
 
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  0C Function  0C 
  Byte Count  08 
  Status Hi  00 
  Status Lo  00 
  Event Count Hi  01 
  Event Count Lo  08 
  Message Count Hi  01 
  Message Count Lo  21 
  Event 0  20 
  Event 1  00 
 
In this example, the status word is 00 00  hex, indicating that the remote device is not 
processing a program function. The event count shows that 264 (01 08 hex) events have been 
counted by the remote device. The message count shows that 289 (01 21 hex) messages 
have been processed.  
The most rece nt communications event is shown in the Event 0 byte. Its content (20 hex) 
show that the remote device has most recently entered the Listen Only Mode.  
The previous event is shown in the Event 1 byte. Its contents (00 hex) show that the remote 
device receiv ed a Communications Restart.  
 
The layout of the response’s event bytes is described below.  
 
What the Event Bytes Contain  
An event byte returned by the Get Communications Event Log function can be any one of four 
types. The type is defined by bit 7 (the high–order bit) in each byte. It may be further defined 
by bit 6. This is explained below.  
 Remote device MODBUS Receive Event  
The remote device stores this type of event byte when a query message is received. It 
is stored before the remote device processes  the message. This event is defined by bit 
7 set to logic ‘1’. The other bits will be set to a logic ‘1’ if the corresponding condition 
is TRUE. The bit layout is:  
Bit Contents  
0 Not Used  
1 Communication Error  
2 Not Used  
3 Not Used  
4 Character Overrun  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  28/50 5 Currently in Listen Only Mode  
6 Broadcast Received  
7 1 
 Remote device MODBUS Send Event  
The remote device stores this type of event byte when it finishes processing a request 
message. It is stored if the remote device returned a normal or exception response, or 
no response. This event is defined by bit 7 set to a logic ‘0’, with bit 6 set to a ‘1’. The 
other bits will be set to a logic ‘1’ if the corresponding condition is TRUE. The bit 
layout is:  
Bit Contents  
0 Read Exception Sent (Exception Codes 1 -3) 
1 Serv er Abort Exception Sent (Exception Code 4)  
2 Server  Busy Exception Sent (Exception Codes 5 -6) 
3 Server  Program NAK Exception Sent (Exception Code 7)  
4 Write Timeout Error Occurred  
5 Currently in Listen Only Mode  
6 1 
7 0 
 Remote device Entered Listen Only Mode  
The remote device stores this type of event byte when it enters the Listen Only Mode. 
The event is defined by a content of 04 hex.  
 
 Remote device Initiated Communication Restart  
The remote device stores this type of event byte when its communications  port is 
restarted. The remote device can be restarted by the Diagnostics function (code 08), 
with sub -function Restart Communications Option (code 00 01).  
That function also places the remote device into a ‘Continue on Error’ or ‘Stop on 
Error’ mode. If t he remote device is placed into ‘Continue on Error’ mode, the event 
byte is added to the existing event log. If the remote device is placed into ‘Stop on 
Error’ mode, the byte is added to the log and the rest of the log is cleared to zeros.  
The event is de fined by a content of zero.  
 
MB Server Sends mb_exception_rsp EXITExceptionCode =  04MB Server receives mb_req_pdu
ExceptionCode = 01NO
YESENTRY
GetCommEventLog == OK
MB Server Sends mb_rspNO
YESFunction code
supported
Request Processing
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  29/50 Figure 20: Get Comm Event Log state diagram  
 
6.11  15 (0x0F) Write Multiple Coils  
This function code is used to force each coil in a sequence of coils to either ON or OFF in a 
remote device. The Request PDU specifies the coil references to be forced. Coils are 
addressed starting at zero. Therefore coil  numbered 1 is addressed as 0.  
The requested ON/OFF states are specified by contents of the request data field. A logical ' 1' 
in a bit position of the field requests the corresponding output to be ON. A logical '0' requests 
it to be OFF.  
The normal response returns the function code, starting address, and quantity of coils forced.  
Request PDU  
Function code  1 Byte  0x0F  
Starting Address  2 Bytes  0x0000 to 0xFFFF  
Quantity of Outputs  2 Bytes  0x0001 to 0x07B0  
Byte Count  1 Byte  N* 
Outputs Value  N* x 1 Byte   
*N = Quantity of Outputs / 8, if the remainder is different of 0  N = N+1  
Response PDU  
Function code  1 Byte  0x0F  
Starting Address  2 Bytes  0x0000 to 0xFFFF  
Quantity of Outputs  2 Bytes  0x0001 to 0x07B0  
 
Error  
Error code  1 Byte  0x8F  
Exception code  1 Byte  01 or 02 or 03 or 04  
 
Here is an example of a request to write a series of 10 coils starting at coil 20:  
The request data contents are two bytes: CD 01 hex (1100 1101 0000 0001 binary). The 
binary bits correspond to the outputs in the following way:  
Bit:  1 1 0 0 1 1 0 1 0 0 0 0 0 0 0 1 
Output :  27 26 25 24 23 22 21 20 – – – – – – 29 28 
The first byte transmitted  (CD hex) addresses outputs 27 -20, with the least significant bit 
addressing the lowest output (20) in this set.  
The next byte transmitted (01 hex) addresses outputs 29 -28, with the least significant bit 
addressing the lowest output (28) in this set. Unuse d bits in the last data byte should be zero –
filled.  
 
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  0F Function  0F 
Starting Address Hi  00 Starting Address Hi  00 
Starting Address Lo  13 Starting Address Lo  13 
Quantity of Outputs Hi  00 Quantity of Outputs Hi  00 
Quantity of Outputs Lo  0A Quantity of Outputs Lo  0A 
Byte Count  02   
Outputs Value Hi  CD   
Outputs Value Lo  01   
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  30/50 
MB Server Sends mb_exception_rsp EXITMB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NO
ExceptionCode = 02YESNO
ExceptionCode =  03YESENTRY
WriteMultipleOutputs  == OK
MB Server Sends mb_rspNO
YES0x0001  Quantity of Outputs  0x07B0
AND
Byte Count = N*Function code
supported
Starting Address == OK
AND
Starting Address + Quantity of Outputs == OK
ExceptionCode =  04*N = Quantity of Outputs / 8, if the
remainder is different of 0  N = N+1
Request Processing 
Figure 21: Write Multiple Outputs state diagram  
 
6.12  16 (0x10) Write Multiple registers  
This function code is used to write a block of contiguous registers (1 to 123 registers) in a 
remote device.  
The requested written values are specified in the request data field. Data is packed as two 
bytes per register.  
The normal response returns the function code, starting address, and quantity of registers 
written.  
 
Request  
Function code  1 Byte  0x10  
Starting Address  2 Bytes  0x0000 to 0xFFFF  
Quantity of Registers  2 Bytes  0x0001 to 0x007B  
Byte Count  1 Byte  2 x N* 
Registers Value  N* x 2 Bytes  value  
*N = Quantity of Registers  
Response  
Function code  1 Byte  0x10  
Starting Address  2 Bytes  0x0000 to 0xFFFF  
Quantity of Registers  2 Bytes  1 to 123 (0x7B)  
 
Error  
Error code  1 Byte  0x90  
Exception code  1 Byte  01 or 02 or  03 or 04  
 
Here is an example of a request to write two registers starting at 2 to 00 0A and 01 02 hex:  
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  10 Function  10 
Starting Address Hi  00 Starting Address Hi  00 
Starting Address Lo  01 Starting Address Lo  01 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  31/50 Quantity of Registers Hi  00 Quantity of Registers Hi  00 
Quantity of Registers Lo  02 Quantity of Registers Lo  02 
Byte Count  04   
Registers Value Hi  00   
Registers Value Lo  0A   
Registers Value Hi  01   
Registers Value Lo  02   
 
 
MB Server Sends mb_exception_rsp EXITMB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NO
ExceptionCode = 02YESNO
ExceptionCode =  03YESENTRY
WriteMultipleRegisters  == OK
MB Server Sends mb_rspNO
YES0x0001  Quantity of Registers  0x007B
AND
Byte Count == Quantity of Registers x 2Function code
supported
Starting Address == OK
AND
Starting Address + Quantity of Registers == OK
ExceptionCode =  04Request Processing
 
Figure 22: Write Multiple Registers state diagram  
 
 
 
6.13  17 (0x11) Report Server  ID (Serial Line only)  
This function code is used to read the description of the type, the current status, and other 
information specific to a remote device.  
The format of a normal response is shown in the following example. The data contents are 
specific to each type of device.  
Request  
Function code  1 Byte  0x11  
Response  
Function code  1 Byte  0x11  
Byte Count  1 Byte   
Server  ID device 
specific   
Run Indicator Status  1 Byte  0x00 = OFF, 0xFF = ON  
Additional Data    
Error  
Error code  1 Byte  0x91  
Exception code  1 Byte  01 or 04  
 
Here is an example of a request to report the ID and status:  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  32/50 Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  11 Function  11 
  Byte Count  Device 
Specific  
  Server  ID Device 
Specific  
  Run Indicator Status  0x00 or 0xFF  
  Additional Data  Device 
Specific  
 
MB Server Sends mb_exception_rsp EXITExceptionCode =  04MB Server receives mb_req_pdu
ExceptionCode = 01NO
YESENTRY
ReportSlaveID == OK
MB Server Sends mb_rspNO
YESFunction code
supported
Request Processing
 
Figure 23: Report server  ID state diagram  
 
6.14  20 (0x14 ) Read File Record  
This function code is used to perform a file record read. All Request Data Lengths are 
provided in terms of number of bytes and all Record Lengths are provided in terms of 
registers.  
A file is an organization of records. Each file contains 10000 records, addressed 0000 to 9999 
decimal or 0X0000 to 0X270F. For example, record 12 is addressed as 12.  
The function can read multiple groups of references. The groups can be separating (non -
contiguous), but the references within each group must be sequential.  
Each group is defined in a separate ‘sub -request’ field that contains 7 bytes:  
The reference type: 1 byte (must be specified as 6)  
The File number: 2 bytes  
The starting record number wit hin the file: 2 bytes  
The length of the record to be read: 2 bytes.  
 
The quantity of registers to be read, combined with all other fields in the expected response, 
must not exceed the allowable length of the MODBUS PDU  : 253 bytes.  
The normal response is a  series of ‘sub -responses’, one for each ‘sub -request’. The byte 
count field is the total combined count of bytes in all ‘sub -responses’. In addition, each ‘sub -
response’ contains a field that shows its own byte count.  
Request  
Function code  1 Byte  0x14  
Byte Count  1 Byte  0x07 to 0xF5 bytes  
Sub-Req. x, Reference Type  1 Byte  06 
Sub-Req. x, File Number  2 Bytes  0x0001  to 0xFFFF  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  33/50 Sub-Req. x, Record Number  2 Bytes  0x0000 to 0x270F  
Sub-Req. x, Record  Length  2 Bytes  N 
Sub-Req. x+1, ...    
Response  
Function code  1 Byte  0x14  
Resp. data Length  1 Byte  0x07 to 0xF5  
Sub-Req. x, File Resp. length  1 Byte  0x07 to 0xF5  
Sub-Req. x, Reference Type  1 Byte  6 
Sub-Req. x, Record Data  N x 2 Bytes   
Sub-Req. x+1, ...    
Error  
Error code  1 Byte  0x94  
Exception code  1 Byte  01 or 02 or 03 or 04 or 
08 
 
While it is allowed for the File Number to be in the range 1 to 0xFFFF, it should be noted that 
interoperability with legacy equipment may be compromised if the File Number is greater than 
10 (0x0A) . 
Here is an example of a request to read two groups of references from remote device:  
 Group 1 consists of two registers from file 4, starting at register 1 (address 0001).  
 Group 2 consists of two registers from file 3, starting at register 9 (address 0009).  
 
 
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  14 Function  14 
Byte Count  0E Resp. Data length  0C 
Sub-Req. 1, Ref. Type  06 Sub-Req. 1, File resp. length  05 
Sub-Req. 1, File Number Hi  00 Sub-Req. 1, Ref. Type  06 
Sub-Req. 1, File Number Lo  04 Sub-Req. 1, Register .Data Hi  0D 
Sub-Req. 1, Record number Hi  00 Sub-Req. 1, R egister .Data Lo FE 
Sub-Req. 1, Record number Lo  01 Sub-Req. 1, Register.Data H i 00 
Sub-Req. 1, Record Length Hi  00 Sub-Req. 1, Register .Data Lo 20 
Sub-Req. 1, Record Length Lo  02 Sub-Req. 2, File resp. length  05 
Sub-Req. 2, Ref. Type  06 Sub-Req. 2, Ref. Type  06 
Sub-Req. 2, File Number Hi  00 Sub-Req. 2, Register.Data H  33 
Sub-Req. 2, File Number Lo  03 Sub-Req. 2, Register .Data Lo CD 
Sub-Req. 2, Record number Hi  00 Sub-Req. 2, Register.Data H i 00 
Sub-Req. 2, Record number Lo  09 Sub-Req. 2, Register .Data Lo 40 
Sub-Req. 2, Record Length Hi  00   
Sub-Req. 2, Record Length Lo  02   MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  34/50 
 
MB Server Sends mb_exception_rsp  EXIT  MB Server receives mb_req_pdu  
ExceptionCode = 01  YES NO 
NO 
ExceptionCode = 02  YES NO 
ExceptionCode =  03 YES ENTRY  
ReadGeneralReference  == OK  
MB Server Sends mb_rsp  NO 
YES 0x07  Byte Count  0xF5  Function code 
supported  
Reference Type == OK  
AND  
File Number == OK  
AND  
Record number == OK  
AND  
Starting Address + Register length  == OK  
 
 
ExceptionCode =  04 Request Processing  For each Sub -Req  
Figure 24: Read File Record state diagram  
 
 
6.15  21 (0x15 ) Write File Record  
This function code is used to perform a file record write. All Request Data Lengths are 
provided in terms of number of bytes and all Record Lengths are provided in terms of the 
number of 16 -bit words.  
A file is an organization of records. Each file contains 10000 records, addressed 0000 to 9999 
decimal or 0X0000 to 0X270F. For example, record 12 is addressed as 12.  
The function can write multiple groups of references. The groups can be separate, i.e. n on–
contiguous, but the references within each group must be sequential.  
Each group is defined in a separate ‘sub -request’ field that contains 7 bytes plus the data:  
The reference type: 1 byte (must be specified as 6)  
The file number: 2 bytes  
The starting record number within the file: 2 bytes  
The length of the record to be written: 2 bytes  
The data to be written: 2 bytes per register.  
 
The quantity of registers to be written, combined with all other fields in the request, must not 
exceed the allowable leng th of the MODBUS PDU  : 253bytes.  
The normal response is an echo of the request.  
Request  
Function code  1 Byte  0x15  
Request data length  1 Byte  0x09 to 0xFB  
Sub-Req. x, Reference Type  1 Byte  06 
Sub-Req. x, File Number  2 Bytes  0x0001  to 0xFFFF  
Sub-Req. x,  Record Number  2 Bytes  0x0000 to 0x270F  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  35/50 Sub-Req. x, Record length  2 Bytes  N 
Sub-Req. x, Record data  N x 2 Bytes   
Sub-Req. x+1, ...    
 
Response  
Function code  1 Byte  0x15  
Response Data length  1 Byte  0x09 to 0xFB  
Sub-Req. x, Reference Type  1 Byte  06 
Sub-Req. x, File Number  2 Bytes  0x0001 to 0xFFFF  
Sub-Req. x, Record number  2 Bytes  0x0000 to 0x 270F  
Sub-Req. x, Record length  2 Bytes  N 
Sub-Req. x, Record Data  N x 2 Bytes   
Sub-Req. x+1, ...    
 
Error  
Error code  1 Byte  0x95  
Exception code  1 Byte  01 or 02 or 03 or 04 or 08  
 
While it is allowed for the File Number to be in the range 1 to 0xFFFF, it should be noted that 
interoperability with legacy equipment may be compromised if the File Number is greater than 
10 (0x0A) . 
Here is an example of a reques t to write one group of references into remote device:  
 The group consists of three registers in file 4, starting at register 7 (address 0007).  
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  15 Function  15 
Request Data length  0D Request Data length  0D 
Sub-Req. 1, Ref. Type  06 Sub-Req. 1, Ref. Type  06 
Sub-Req. 1, File Number Hi  00 Sub-Req. 1, File Number Hi  00 
Sub-Req. 1, File Number Lo  04 Sub-Req. 1, File Number Lo  04 
Sub-Req. 1, Record number Hi  00 Sub-Req. 1, Record number Hi  00 
Sub-Req. 1, Record number Lo  07 Sub-Req. 1, Record number 
Lo 07 
Sub-Req. 1, Record length Hi  00 Sub-Req. 1, Record length Hi  00 
Sub-Req. 1, Record length Lo  03 Sub-Req. 1, Record length Lo  03 
Sub-Req. 1, Register  Data Hi  06 Sub-Req. 1, Register  Data Hi  06 
Sub-Req. 1, Register  Data Lo  AF Sub-Req. 1, Register  Data Lo  AF 
Sub-Req. 1, Register  Data Hi  04 Sub-Req. 1, Register  Data Hi  04 
Sub-Req. 1, Register  Data Lo  BE Sub-Req. 1, Register  Data Lo  BE 
Sub-Req. 1, Register  Data Hi  10 Sub-Req. 1, Register  Data  Hi 10 
Sub-Req. 1, Register  Data Lo  0D Sub-Req. 1, Register  Data Lo  0D 
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  36/50 
MB Server Sends mb_exception_rsp EXITMB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NO
ExceptionCode = 02YESNO
ExceptionCode =  03YESENTRY
WriteGeneralReference  == OK
MB Server Sends mb_rspNO
YES0x07  Byte Count  0xF5Function code
supported
Reference Type == OK
AND
File Number == OK
AND
Record number == OK
AND
Starting Address + Register length  == OK
ExceptionCode =  04Request ProcessingFor each Sub-Req 
 
Figure 25: Write File Record state diagram  
 
6.16  22 (0x16) Mask Write Register  
This function code is used to modify the contents of a specified holding register using a 
combination of an AND mask, an OR mask, and the register's current contents. The function 
can be used to set or clear individual bits in the register.  
The request specifies the holding register to be written, the data to be used as the AND mask, 
and the data to be used as the OR mask. Registers are addressed starting at zero. Therefore 
registers 1 -16 are addressed as 0 -15. 
The function’s algorithm is:  
Result = (Curr ent Contents AND And_Mask) OR (Or_Mask AND (NOT And_Mask))  
For example:   
  Hex Binary  
Current Contents=    12 0001 0010  
And_Mask =    F2 1111 0010  
Or_Mask =    25 0010 0101  
 
(NOT And_Mask)=    0D 0000 1101  
 
Result =    17 0001 0111  
 Note : 
 If the Or_Mask valu e is zero, the result is simply the logical ANDing of the current contents and 
And_Mask. If the And_Mask value is zero, the result is equal to the Or_Mask value.  
 The contents of the register can be read with the Read Holding Registers function (function code 03). 
They could, however, be changed subsequently as the controller scans its user logic program.  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  37/50  
The normal response is an echo of the request. The response is returned after the register 
has been written.  
Request  
Function code  1 Byte  0x16  
Reference Address  2 Bytes  0x0000 to 0xFFFF  
And_Mask  2 Bytes  0x0000 to 0xFFFF  
Or_Mask  2 Bytes  0x0000 to 0xFFFF  
 
Response  
Function code  1 Byte  0x16  
Reference Address  2 Bytes  0x0000 to 0xFFFF  
And_Mask  2 Bytes  0x0000 to 0xFFFF  
Or_Mask  2 Bytes  0x0000 to 0xFFFF  
 
Error  
Error code  1 Byte  0x96  
Exception code  1 Byte  01 or 02 or 03 or 04  
 
Here is an example of a Mask Write to register 5 in remote device, using the above mask 
values.  
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  16 Function  16 
Reference address Hi  00 Reference address Hi  00 
Reference address Lo  04 Reference address Lo  04 
And_Mask Hi  00 And_Mask Hi  00 
And_Mask Lo  F2 And_Mask Lo  F2 
Or_Mask Hi  00 Or_Mask Hi  00 
Or_Mask Lo  25 Or_Mask Lo  25 
 
 
 
MB Server Sends mb_exception_rspEXITMB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NOExceptionCode = 02
YESNO
ExceptionCode =  03YESENTRY
MaskWriteRegister  == OK
MB Server Sends mb_rspNO
YESFunction code
supported
ExceptionCode =  04Request ProcessingReference Address == OK
AND_Mask == OK
AND
OR_Mask == OK
 
Figure 26: Mask Write Holding Register state diagram  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  38/50  
 
6.17  23 (0x17) Read/Write Multiple registers  
This function code performs a combination of one read operation and one write operation in a 
single MODBUS transaction.  The write operation is performed before the read.  
Holding registers are addressed starting at zero. Therefore holding registers 1 -16 are 
addressed in the PDU as 0 -15. 
The request specifies the starting address and number of holding registers to be read as well 
as th e starting address,  number of holding registers, and the data to be written. The byte 
count specifies the number of bytes to follow in the write data field.  
The normal response contains the data from the group of registers that were read. The byte 
count f ield specifies the quantity of bytes to follow in the read data field.  
 
Request  
Function code  1 Byte  0x17  
Read Starting Address  2 Bytes  0x0000 to 0xFFFF  
Quantity to Read  2 Bytes  0x0001 to 0x007D  
Write Starting Address  2 Bytes  0x0000 to 0xFFFF  
Quantity  to Write  2 Bytes  0x0001 to 0X007 9 
Write Byte Count  1 Byte  2 x N* 
Write Registers Value  N*x 2 Bytes   
*N = Quantity to Write  
 
Response   
Function code  1 Byte  0x17  
Byte Count  1 Byte  2 x N'* 
Read Registers value  N'* x 2 Bytes   
*N' = Quantity to Read  
 
Error  
Error code  1 Byte  0x97  
Exception code  1 Byte  01 or 02 or 03 or 04  
 
 
Here is an example of a request to read six registers starting at register 4, and to write three 
registers starting at register 15:  
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  17 Function  17 
Read Starting Address Hi  00 Byte Count  0C 
Read Starting Address Lo  03 Read Registers value Hi  00 
Quantity to Read Hi  00 Read Registers value Lo  FE 
Quantity to Read Lo  06 Read Registers value Hi  0A 
Write Starting Address Hi 00 Read Registers value Lo  CD 
Write Starting address Lo  0E Read Registers value Hi  00 
Quantity to Write Hi  00 Read Registers value Lo  01 
Quantity to Write Lo  03 Read Registers value Hi  00 
Write Byte Count  06 Read Registers value Lo  03 
Write Registers Value Hi  00 Read Registers value Hi  00 
Write Registers Value Lo  FF Read Registers value Lo  0D 
Write Registers Value Hi  00 Read Registers value Hi  00 
Write Registers Value Lo  FF Read Registers value Lo  FF 
Write Registers Value Hi  00   
Write Registers Value Lo  FF   
 
  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  39/50 
MB Server Sends mb_exception_rsp EXITMB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NO
ExceptionCode = 02YESNO
ExceptionCode =  03YESENTRY
Read/WriteMultipleRegisters == OK
MB Server Sends mb_rspNO
YES0x0001  Quantity of Read  0x007D
AND
0x0001  Quantity of Write  0x0079
AND
Byte Count == Quantity of Write x 2Function code
supported
 Read Starting Address == OK
AND
Read Starting Address + Quantity of Read == OK
AND
Write Starting Address == OK
AND
Write Starting Address + Quantity of Write == OK
ExceptionCode =  04Request Processing
Write operation before read operation 
Figure 27: Read/Write Multiple Registers state diagram  
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  40/50 6.18  24 (0x18) Read FIFO Queue  
This function code allows to read  the contents of a First -In-First -Out (FIFO) queue of register 
in a remote device. The function returns a count of the registers in the queue, followed by the 
queued data. Up to 32 registers can be read: the count, plus up to 31 queued data registers. 
The queue count register is returned first, followed by the queued data registers.  
The function reads the queue contents, but does not clear them.  
In a normal response, the byte count shows the quantity of bytes to follow, including the 
queue count bytes and v alue register bytes (but not including the error check field).  
The queue count is the quantity of data registers in the queue (not including the count 
register).  
If the queue count exceeds 31, an exception response is returned with an error code of 03 
(Illegal Data Value).  
Request  
Function code  1 Byte  0x18  
FIFO Pointer Address  2 Bytes  0x0000 to 0xFFFF  
 
Response  
Function code  1 Byte  0x18  
Byte Count  2 Bytes   
FIFO Count  2 Bytes   31 
FIFO Value Register  N* x 2 Bytes   
*N = FIFO Count  
Error  
Error code  1 Byte  0x98  
Exception code  1 Byte  01 or 02 or 03 or 04  
 
Here is an example of Read FIFO Queue request to remote device. The request is to read the 
queue starting at the pointer register 1246 (0x04DE):  
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  18 Function  18 
FIFO Pointer Address Hi  04 Byte Count Hi  00 
FIFO Pointer Address Lo  DE Byte Count Lo  06 
  FIFO Count Hi  00 
  FIFO Count Lo  02 
  FIFO Value Register Hi  01 
  FIFO Value Register Lo  B8 
  FIFO Value Register Hi  12 
  FIFO Value Register Lo  84 
 
In this example, the FIFO pointer register (1246 in the request) is returned with a queue count 
of 2. The two data registers follow the queue count. These are:  
1247 (contents 440 decimal -- 0x01B8); and 1248 (contents 4740 -- 0x1284).  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  41/50 
MB Server Sends mb_exception_rsp EXITMB Server receives mb_req_pdu
ExceptionCode = 01YESNO
NO
ExceptionCode = 03YESNO
ExceptionCode =  02YESENTRY
ReadFIFOQueue  == OK
MB Server Sends mb_rspNO
YES0x0000  FIFO Pointer Address  0xFFFFFunction code
supported
ExceptionCode =  04FIFO Count  31
Request Processing 
Figure 28: Read FIFO Queue state diagram  
 
 
 
 
6.19  43 ( 0x2B) Encapsulated Interface Transport  
Informative Note:  The user is asked to refer to Annex A (Informative) MODBUS RESERVED 
FUNCTION CODES, SUBCODES AND  MEI TYPES.  
Function Code 43 and its MEI Type 14 for Device Identification is one of two Encapsulated 
Interface Transport currently available in this Specification.  The following function codes and 
MEI Types shall not be part of this published Specificati on and these function codes and MEI 
Types are specifically reserved: 43/0 -12 and 43/15 -255.  
The MODBUS Encapsulated Interface (MEI)Transport is a mechanism for tunneling service 
requests and method invocations,  as well as their returns, inside MODBUS PDUs . 
The primary feature of the MEI Transport is the encapsulation of method invocations or 
service requests that are part of a defined interface as well as method invocation returns or 
service responses.  
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  42/50  
Figure 29: MODBUS encapsu lated Interface Transport  
 
The Network Interface  can be any communication stack used to send MODBUS PDUs, such 
as TCP/IP, or serial line.  
A MEI Type  is a MODBUS Assigned Number and therefore will be unique,  the value between 
0 to 255 are Reserved accordi ng to Annex A (Informative) except for MEI Type 13 and MEI 
Type 14.  
The MEI Type is used by MEI Transport implementations to dispatch a method invocation to 
the indicated interface.  
Since the MEI Transport service is interface agnostic, any specific behav ior or policy required 
by the interface must be provided by the interface, e.g. MEI transaction processing, MEI 
interface error handling, etc.  
 
Request  
Function code  1 Byte  0x2B  
MEI Type*  1 Byte  0x0D or 0x0E  
MEI type specific data  n Bytes   
 
* MEI = MODBUS Encapsulated Interface  
Response  
Function code  1 Byte  0x2B  
MEI Type  1 byte  echo of MEI Type in 
Request  
MEI type specific data   n Bytes   
 
Error  
Function  code  1 Byte  0xAB :  
Fc 0x2B + 0x80  
Exception code  1 Byte  01 or 02 or 03 or  04 
 
As an example see Read device identification request.  
 
6.20  43 / 13 (0x2B / 0x0D) CANopen General Reference Request and Response PDU  
The CANopen General reference Command is an encapsulation of the services that will be 
used to access (read from or write to) t he entries of a CAN -Open Device Object Dictionary as 
well as controlling an d monitoring the CANopen system, and devices.   
The MEI Type 13 (0x0D) is a MODBUS Assigned Number licensed to CiA for the CANopen 
General Reference.  
The system is intended to work within the limitations of existing MODBUS networks. 
Therefore, the information needed to query or modify the object dictionaries in the system is 
MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  43/50 mapped into the format o f a MODBUS message.  The PDU will have the 253  Byte limitation in 
both the Request and  the Response message.   
Informative:  Please refer to Annex B for a reference to a specification that provides 
information on MEI Type 13.  
6.21  43 / 14 (0x2B / 0x0E) Read Device Identification  
This function code allows reading the identification and additional  information relative to the 
physical and functional description of a remote device, only.  
The Read Device Identification interface is modeled as an address space composed of a set 
of addressable data elements. The data elements are called objects and an object Id identifies 
them.  
The interface consists of 3 categories of objects :  
 Basic Device Identification. All objects of this category are mandatory : VendorName, 
Product code, and revision number.  
 Regular Device Identification. In addition to Basic data objects, the device provides 
additional and optional identification and description data objects. All of the objects of 
this category are defined in the standard but their implementation is optional . 
 Extended Device Identification. In addition to regular data objects, the device provides 
additional and optional identification and description private data about the physical 
device itself. All of these data are device dependent.  
 
Object 
Id Object Name / Description  Type  M/O  category  
0x00  VendorName  ASCII String  Mandatory  Basic  
  0x01  ProductCode  ASCII String  Mandatory  
0x02  MajorMinorRevision  ASCII String  Mandatory  
0x03  VendorUrl  ASCII String  Optional  Regular  
0x04  ProductName  ASCII String  Optional  
0x05  ModelName  ASCII String  Optional  
0x06  UserApplicationName  ASCII String  Optional  
0x07  
… 
0x7F  Reserved  
  Optional  
0x80  
… 
0xFF  Private objects may be optionally  
defined.  
The range [0x80 – 0xFF] is Product 
dependant.  device 
dependant  Optional  Extended  
 
Request  
Function code  1 Byte  0x2B  
MEI Type*  1 Byte  0x0E  
Read Device ID code  1 Byte  01 / 02 / 03 / 04  
Object Id  1 Byte  0x00 to 0xFF  
* MEI = MODBUS Encapsulated Interface  
Response  
Function code  1 Byte  0x2B  
MEI Type  1 byte  0x0E  
Read Device ID code  1 Byte  01 / 02 / 03 / 04  
Conformity level  1 Byte  0x01 or 0x02 or 0x03 or 
0x81 or 0x82 or 0x83  
More Follows  1 Byte  00 / FF  
Next Object Id  1 Byte  Object ID number  
Number of objects    1 Byte   
List Of    
Object ID    1 Byte   
Object length   1 Byte   
Object Value   Object length  Depending on the object ID  
 
Error  
Function  code  1 Byte  0xAB :  
Fc 0x2B + 0x80  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  44/50 Exception code  1 Byte  01 or  02 or 03 or  04 
 
 
Request parameters description :  
A MODBUS Encapsulated Interface assigned number 14 identifies the Read identification 
request.  
The parameter " Read Device ID code " allows to define four access types  :  
01: request  to get the basic device identification (stream access)  
02: request to get the regular device identification (str eam access)  
03: request to get the  extended device identification (stream access)  
04: request to get one specific identification object (individual access)  
An exception code 03 is sent back in the response if the Read device ID code is illegal.  
In case of a response that does not fit into a single response, several  transactions 
(request/response ) must be done. The Object Id byte gives the identification of the first 
object to obtain. For the first transaction, the client must set the Object Id to 0 to obtain 
the beginning of the device identification data. For the following transactions, the client 
must set the Object Id to the value returned by the server in its previous response.  
Remark :  An object is indivisible, therefore any object must ha ve a size consistent with 
the size of  transaction response.  
 
If the Object Id does not match any known object, the server responds as if object 0 were 
pointed out (restart at the beginning).  
 In case of an individual access: ReadDevId code 04 , the Object  Id in the request gives 
the identification of the object to obtain, and if the Object Id doesn't match to any known 
object, the server returns an exception response with exception code = 02 (Illegal data 
address).  
If the server device is asked for a desc ription level ( readDevice Code )higher that its 
conformity level , It must respond in accordance with its actual conformity level.  
 
Response parameter description :  
Function code :  Function code 43 (decimal) 0x2B (hex)  
MEI Type  14 (0x0E) MEI Type assign ed number for Device Identification 
Interface  
ReadDevId code :  Same as request ReadDevId code : 01, 02, 03 or 04  
Conformity Level  Identification conformity level of the device and type of supported 
access  
0x01: basic identification (stream access only)  
0x02: regular identification (stream access only)  
0x03: extended identification (stream access only)  
0x81: basic identification (stream access and individual access)  
0x82: regular identification (stream access and individual access)  
0x83: extended identificat ion(stream access and individual 
access)  
More Follows  In case of ReadDevId codes 01, 02 or 03 (stream access),  
If the identification data doesn't fit into a single response, several 
request/response transactions may be required.  
0x00 : no more Object are a vailable  
0xFF : other identification Object are available and further 
MODBUS transactions are required  
In case of ReadDevId code 04 (individual access),  
this field must be set to 00.  
Next Object Id  If "MoreFollows = FF", identification of the next Object to be 
asked for.  
If "MoreFollows = 00", must be set to 00 (useless)  
Number Of Objects  Number of identification Object returned in the response  
(for an individual access, Number Of Objects = 1)  
Object0.Id  Identification of the first Object returned in the P DU (stream 
access) or the requested Object (individual access)  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  45/50 Object0.Length  Length of the first Object in byte  
Object0.Value  Value of the first Object (Object0.Length bytes)  
… 
ObjectN.Id  Identification of the last Object (within the response)  
ObjectN.Len gth Length of the last Object in byte  
ObjectN.Value  Value of the last Object (ObjectN.Length bytes)  
Example of a Read Device Identification request for "Basic device identification" : In this 
example all information are sent in one response PDU.  
Request  Response  
Field Name  Value  Field Name  Value  
Function  2B Function  2B 
 MEI Type  0E MEI Type  0E 
Read Dev Id code  01 Read Dev Id Code  01 
Object Id  00 Conformity Level  01 
  More Follows  00 
  NextObjectId  00 
  Number Of Objects  03 
  Object Id  00 
  Object Length  16 
  Object Value  " Company identification"  
  Object Id  01 
  Object Length  0D 
  Object Value  " Product code XX"  
  Object Id  02 
  Object Length  05 
  Object Value  "V2.11"  
 
In case of a device that required several transactions to send the response the following 
transactions is intiated.  
First transaction :  
 
Request  Response  
Field Name  Value  Field Name  Value  
Function  2B Function  2B 
 MEI Type  0E MEI Type  0E 
Read Dev Id code  01 Read Dev Id Code  01 
Object Id  00 Conformity Level  01 
  More Follows  FF 
  NextObjectId  02 
  Number Of Objects  03 
  Object Id  00 
  Object Length  16 
  Object Value  " Company identification"  
  Object Id  01 
  Object Length  1C 
  Object Value  " Product code 
XXXXXXXXXXXXXXXX"  
 
 
Second transaction :  
 
 
Request  Response  
Field Name  Value  Field Name  Value  
Function  2B Function  2B 
 MEI Type  0E MEI Type  0E 
Read Dev Id code  01 Read Dev Id Code  01 
Object Id  02 Conformity Level  01 
  More Follows  00 
  NextObjectId  00 
  Number Of Objects  03 
  Object Id  02 
  Object Length  05 
  Object Value  "V2.11"  
 
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  46/50  
 
NO YES  
MB Server Sends 
mb_exception_rsp  EXIT  MB Server receives mb_req_pdu  
ExceptiCode = 01  YES NO 
More follows = FF  
Next Object ID = XX  NO 
Except.Code =  02 YES ENTRY  
MB Server Sends mb_rsp  NO Object Id OK  
 Function code 
supported  
 
Segmentation required  
 Request Processing  
More follows = 00  
Next Object ID = 00  Read deviceId Code OK  
Except. Code =03  
 
Figure 30: Read Device Identification state diagram  
 
  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  47/50 7 MODBUS Exception Responses  
When a client  device sends a request to a server  device it expects a normal response. One 
of four possible events can occur from the client ’s query:  
 If the server  device receives the request without a communication error, and can 
handle the query normally, it returns a normal response.  
 If the server  does not receive the request due to a communication error, no response 
is returned. The client  program will eventually  process a timeout condition for the 
request.  
 If the server  receives the r equest, but detects a communication error (parity, LRC, 
CRC, ...), no response is returned. The client  program will eventually process a 
timeout condition for the request.  
 If the server  receives the request without a communication error, but cannot handl e it 
(for example, if the request is to read a non –existent output or register), the server  
will return an exception response informing the client  of the nature of the error.  
 
The exception response message has two fields that differentiate it from a nor mal response:  
Function Code Field: In a normal response, the server  echoes the function code of the 
original request in the function code field of the response. All function codes have a most –
significant bit (MSB) of 0 (their values are all below 80 hexad ecimal). In an exception 
response, the server  sets the MSB of the function code to 1. This makes the function code 
value in an exception response exactly 80 hexadecimal higher than the value would be for a 
normal response.  
With the function code’s MSB set , the client's  application program can recognize the 
exception response and can examine the data field for the exception code.  
Data Field: In a normal response, the server  may return data or statistics in the data field 
(any information that was requeste d in the request). In an exception response, the server  
returns an exception code in the data field. This defines the server  condition that caused the 
exception.  
 
Example of a client  request and server exception response  
 
Request  Response  
Field Name  (Hex)  Field Name  (Hex)  
Function  01 Function  81 
Starting Address Hi  04 Exception Code  02 
Starting Address Lo  A1   
Quantity of Outputs Hi  00   
Quantity of Outputs Lo  01   
 
In this example, the client  addresses a request to server  device. The function code (01) is for 
a Read Output Status operation. It requests the status of the output at address 1185  (04A1 
hex). Note that only that one output is to be read, as specified by  the number of outputs field 
(0001).  
If the output address is non –existent in the server  device, the server  will return the exception 
response with the exception code shown (02). This specifies an illegal data address for the 
server . 
 
A listing of except ion codes begins on the next page.  
 
  MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  48/50 MODBUS Exception Codes  
Code  Name  Meaning  
01 ILLEGAL FUNCTION  The function code received in the query is not an 
allowable action for the server . This may be 
because the function code is only applicable to 
newer devices, and was not implemented in the 
unit selected. It could also indicate that the server  
is in the wrong state to process a request of this 
type, for example because it is unconfigure d and 
is being asked to return register values.  
02 ILLEGAL DATA ADDRESS  The data address received in the query is not an 
allowable address for the server . More 
specifically, the combination of reference number 
and transfer length is invalid. For a control ler with 
100 registers, the PDU addresses the first register 
as 0, and the last one as 99. If a request is 
submitted with a starting register address of 96 
and a quantity of registers of 4, then this request 
will successfully operate (address -wise at least ) 
on registers 96, 97, 98, 99. If a request is 
submitted with a starting register address of 96 
and a quantity of registers of 5, then this request 
will fail with Exception Code 0x02 “Illegal Data 
Address” since it attempts to operate on registers 
96, 97, 98, 99 and 100, and there is no register 
with address 100.  
03 ILLEGAL DATA VALUE  A value contained in the query data field is not an 
allowable value for server . This indicates a fault in 
the structure of the remainder of a complex 
request, such as that th e implied length is 
incorrect. It specifically does NOT mean that a 
data item submitted for storage in a register has a 
value outside the expectation of the application 
program, since the MODBUS protocol is unaware 
of the significance of any particular val ue of any 
particular register.  
04 SERVER  DEVICE FAILURE  An unrecoverable error occurred while the server  
was attempting to perform the requested action.  
05 ACKNOWLEDGE  Specialized use in conjunction with programming 
commands.  
The server  has accepted the request and is 
processing it, but a long duration of time will be 
required to do so. This response is returned to 
prevent a timeout error from occurring in the 
client. The client can next issue a Poll Program 
Complete message to determine if processing is 
completed.  
06 SERVER  DEVICE BUSY  Specialized use in conjunction with programming 
commands.  
The server  is engaged in processing a long –
duration program command. The client  should 
retransmit the message later when the server  is 
free.  
08 MEMORY PARITY ERROR  Specialized use in conjunction with function codes 
20 and 21 and reference type 6, to indicate that 
the extended file area failed to pass a consistency 
check.  
The server  attempted to read record file, but 
detected a parity error in the memory. The client 
can retry the request, but service may be required MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26 , 2012 http://w ww.modbus.org  49/50 on the server device.  
0A GATEWAY PATH UNAVAILABLE  Specialized use in conjunction with gateways, 
indicates that the gate way was unable to allocate 
an internal communication path from the input port 
to the output port for processing the request. 
Usually means that the gateway is misconfigured 
or overloaded.  
0B GATEWAY TARGET DEVICE 
FAILED TO RESPOND  Specialized use in conju nction with gateways, 
indicates that no response was obtained from the 
target device. Usually means that the device is not 
present on the network.  
 MODBUS Application Protocol Specification V1.1b3  Modbus  
April 26,  2012 http://www.modbus.org  50/50 Annex A (Informative): MODBUS  RESERVED FUNCTION CODES, SUBCODES 
AND MEI TYPES  
The following function codes and subcodes shall not be part of this published Specification 
and these function codes and subcodes are specifically reserved.   The format is function 
code/subcode or just func tion code where all the subcodes (0 -255) are reserved: 8/19; 8/21 -
65535, 9, 10, 13, 14, 41, 42, 90, 91, 125, 126 and 127.  
Function Code 43 and its MEI Type 14 for Device Identification and MEI Type 13 for 
CANopen General Reference Request and Response  PDU are the currently available 
Encapsulated Interface Transports in this Specification.  
The following function codes and MEI Types shall not be part of this published Specification 
and these function codes and MEI Types are specifically reserved: 43/0 -12 and  43/15 -255.  
In this Specification, a User Defined Function code having the same or similar result as the 
Encapsulated Interface Transport is not supported.  
MODBUS  is a registered trademark of Schneider Automation Inc.  
Annex B (Informative): CANOPEN GENE RAL REFERENCE COMMAND  
Please refer to the MODBUS website or the CiA (CAN in Automation) website for a copy and 
terms of use that cover Function Code 43 MEI Type 13.   
 
 MODBUS Messaging on TCP/IP Implementation Guide V1.0b Modbus Organization  
October 24, 2006 http://www.Modbus.org 1/46MODBUS MESSAGING ON TCP/IP  IMPLEMENTATION GUIDE 
V1.0b 
CONTENTS 
1 INTRODUCT ION ........................................................................................................... 2  
1.1 OBJECTIVES ....................................................................................................... 2  
1.2 CLIENT / SERVER  MODEL................................................................................... 2  
1.3 REFERENCE DO CUMENTS ................................................................................. 3  
2 ABBREVIATIO NS .......................................................................................................... 3  
3 CONTEXT ..................................................................................................................... 3  
3.1 PROTOCOL DES CRIPTION ................................................................................. 3  
3.1.1  General communication  architec ture ......................................................... 3  
3.1.2  MODBUS On TCP/IP App lication Data  Unit ............................................... 4  
3.1.3  MBAP Header de scripti on ......................................................................... 5  
3.2 MODBUS FUNCTIONS CO DES DESCRI PTION .................................................... 6  
4 FUNCTIONAL DES CRIPTION........................................................................................ 7  
4.1 MODBUS COMPONENT A RCHITECTURE MODEL............................................... 7  
4.2 TCP CONNECTION MANAGEME NT ....................................................................10  
4.2.1  Connections managem ent Modul e............................................................10  
4.2.2  Impact of Operating Modes on the TCP Co nnecti on..................................13  
4.2.3  Access Contro l Modu le ............................................................................14  
4.3 USE of TCP/IP  STACK ........................................................................................14  
4.3.1  Use of BSD Socke t interf ace ....................................................................15  
4.3.2  TCP  layer param eterizat ion.....................................................................18  
4.3.3  IP layer paramet erizatio n .........................................................................19  
4.4 COMMUNICATION APPL ICATION LAYER...........................................................20  
4.4.1  MODBUS C lient .......................................................................................20  
4.4.2  MODBUS Se rver......................................................................................26  
5 IMPLEMENTATION GUIDELIN E ...................................................................................32  
5.1 OBJECT MODEL DIAGRAM ................................................................................32  
5.1.1  TCP managemen t pack age ......................................................................33  
5.1.2  Configuration la yer pack age.....................................................................35  
5.1.3  Communication la yer pack age..................................................................36  
5.1.4  Interface cl asses......................................................................................37  
5.2 IMPLEMENTATION CLASS DIAGRAM.................................................................37  
5.3 SEQUENCE DI AGRAMS......................................................................................39  
5.4 CLASSES AND METHODS DESCRIPT ION ..........................................................42  
5.4.1  MODBUS Server  Class ............................................................................42  
5.4.2  MODBUS Client Class..............................................................................43  
5.4.3  Interface Cl asses.....................................................................................44  
5.4.4  Connexion Management  class..................................................................45  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
1 INTRODUCTION 
1.1 OBJECTIVES 
The objective of this document is to pr esent the MODBUS messaging service over 
TCP/IP , in order to provide reference info rmation that helps software developers to 
implement this service. The encoding of the MODBUS function codes is not described 
in this document, for this information plea se read the MODBUS Application Protocol 
Specification [1].   
This document gives accurate and comprehensive description of a MODBUS messaging 
service implementation. Its purpose is to facilitate the interoperability between the devices using the MODBUS messaging service. 
This docu ment c
omprises mainly three parts:  
•An overview of the MODBUS over TCP/IP protocol
•A functional description of a MODBUS client, server and gateway
implementation.
•An implementation guideline that prop oses the object model of an MODBUS
implementation example.
1.2 CLIENT / SERVER MODEL 
The MODBUS messaging service provides a Client/Server communication between 
devices connected on an Ethernet TCP/IP network. 
This client / server model is based on four type of messages:  
•MODBUS Request,
•MODBUS Confirmation,
•MODBUS Indication,
•MODBUS Response
MODBUS Client MODBUS Serve rRequest Indication
Response Confirmation
A MODBUS Request  is the message sent on the network by the Client to initiate a 
transaction, 
A MODBUS Indication is the Request message received on the Server side, A MODBUS Response is the Response message sent by the Server, 
A MODBUS Confirmation is the Response Message received on the Client side 
The MODBUS messaging services (Client / Server Model) are used for real time 
information exchange: 
•between two device applications,
•between device application and other device,
•between HMI/SCADA applications and devices,
•between a PC and a device program providing on line services.
October 24, 2006 http://www.Modbus.org 2/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 3/46-  
1.3 REFERENCE DOCUMENTS 
This section gives a list of documents that ar e interest ing to read before this  one: 
[1] MODBUS Application Prot ocol Specification V1.1a.
[2] RFC 1122 Requirements for Internet Hosts -- Communication Layers
2 ABBREVIATIONS 
ADU Application Data Unit 
IETF  Internet Engineering Task Force 
IP Internet 
Protocol  
MAC  Medium Access Control  
MB MODBUS  
MBAP  MODBUS Application Protocol 
PDU  Protocol Data Unit 
PLC  Programmable Logic Controller  
TCP  Transport Control Protocol 
BSD   Berkeley Software Distribution 
MSL Maximum Segment Lifetime  
3 CONTEXT 
3.1 PROTOCOL DESCRIPTION 
3.1.1 General communication architecture 
A communicating system over MODBUS TCP/IP may include different types of device: 
•A MODBUS TCP/IP Client and Server dev ices connected to a TCP/IP network
•The Interconnection devices like bridge, router or gateway for interconnection
between the TCP/IP network and a serial line sub-network which permit
connections of MODBUS Serial line Client and Server end devices.Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
MODBU
S Client 
TCP/IP 
MODBU
S Server 
TCP/IP MODBU
S Server 
TCP/IP MODBUS 
Server 
Serial Line MODBUS 
Server 
Serial Line MODBUS 
Client 
Serial Line 
MODBU
S Client 
TCP/IP 
MODBUS Client 
TCP/IP
Server TCP/IP
gatewa y
MODBUS Serial 
Figure 1: MODBUS TCP/IP communication architecture 
The MODBUS protocol defines a simple Protocol Data Unit  (PDU) independent of the 
underlying communication layers. The mapping of MODBUS protocol on specific buses 
or networks can introduce some additional fields on the Application Data Unit  (ADU).  
Additional address Function code Data Error checkADU
PDU
Figure 2: General MODBUS frame 
The client that initiates a MODBUS transaction builds the MODBUS Application Data 
Unit. The function code indicates to the se rver which kind of action to perform. 
3.1.2 MODBUS On TCP/IP Application Data Unit 
This section describes the encapsulation of a MODBUS request or response when it is carried on a MODBUS TCP/IP network.  
Function code Data MBAP Header
PDUMODBUS TCP/IP ADU
Figure 3: MODBUS request/response over TCP/IP 
A dedicated header is used on TCP/IP to ident ify the MODBUS Application Data Unit. It 
is called the MBAP header (MODBUS A pplication Protocol header).  
October 24, 2006 http://www.Modbus.org 4/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 5/46This header provides some differences comp ared to the MODBUS RTU application data 
unit used on serial line:  
The MODBUS ‘slave address’ field usua lly used on MODBUS Serial Line is
replaced by a s
ingle byte ‘Unit Identifier’ within the MBAP Header. The
‘Unit Identifier’ is used to communicate via devices such as bridges,
routers and gateways that use a single IP address to support multiple
independent MODBUS end units.
All MODBUS requests and responses are designed in such a way that therecipient can verify that a message is finished. For function codes wherethe MODBUS PDU has a fixed length, the func
tion code alone is sufficient.
For function codes carrying a variable amount of data in the request orresponse, the data field includes a byte count.
When MODBUS is carried over TCP, additional length information is
carried in 
the MBAP header to allow the recipient to recognize message
boundaries even if the message has been split into multiple packets fortransmission. The existence of explicit and implicit length rules, and use of
a CRC-32 error check code (on Ethernet) results in an infinitesimal chanceof undetected corruption to a request or response message.
3.1.3 MBAP Header description 
The MBAP Header contains the following fields: 
Fields  Length Description - Client  Server  
Transaction 
Identifier  2 Bytes Identification of a 
MODBUS Request / Response transaction. Initialized by the client  Recopied by the server from the receiv ed 
request  
Protocol Identifier 2 Bytes  0 = MODBUS protocol Initialized by the client Recopied by the server from the received 
request 
Length 2 Bytes Number of following 
bytes  Initialized by the client ( request) Initialized by the server ( 
Response)  
Unit Identifier 1 Byte Identification of a 
remote slave connected on a serial line or on other buses. Initialized by the client Recopied by the server from the received 
request 
The header is 7 bytes long: 
•Transaction Identifier   - It is used for transaction pairing, the MODBUS server copies
in the response the transaction identifier of the request.
•Protocol Identifier   – It is  used for intra-system mu ltiplexing. The MODBUS protocol
is identified by the value 0.
•Length  - The length field is a byte count of the following fields, including the Unit
Identifier and data fields.Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 6/46•Unit Identifier  – This field is used for intra-system  routing purpose.  It is typically
used to communicate to a MODBUS+ or a MODBUS serial line slave through a
gateway between an Ethernet TCP-IP network and a MODBUS serial line. This field is
set by the MODBUS Client in the request and must be returned with the same value in
the response by the server.
All MODBUS/TCP ADU are sent via TCP to registered port 502.  
Rem
ark : the different fields are encoded in Big-endian. 
3.2 MODBUS FUNCTIONS CODES DESCRIPTION 
Standard function codes used on MODBUS applic ation layer protocol are described in 
details in the MODBUS Applicat ion Protocol Specification [1]. Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
4 FUNCTIONAL DESCRIPTION 
The MODBUS Component Architecture presented here is a general model including 
both MODBUS Client and Server Components and usable on any device.  
Some devices may only provide the server or the client component. In the first part of this section a brief overview of the MODBUS messaging service 
component architecture is given, follo wed by a description of each component 
presented in the architectural model. 
4.1 
MODBUS COMPONENT ARCHITECTURE MODEL 
USER
APPLICATION
Communication
Application
Layer
Modbus Client Modbus ServerModbus Client
Interface
TCP
Management
Connection
 ManagementAccess Ctl
TCP/IP StackStack
parmeterizationModbus Backend
InterfaceRessource Management
&
Flow Control
Figure 4: MODBUS Messaging Service Conceptual Architecture 
•Communication Application Layer
A MODBUS device may provide a client and/or a server MODBUS interface. 
A MODBUS backend interface can be provided allowing indirectly the access to user 
application objects.  
Four areas can compose this 
interface: input discrete, output discrete (coils), input 
registers and output registers. A pre-mapping  between this interface and the 
user 
application data has to be done (local issue). 
October 24, 2006 http://www.Modbus.org 7/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Primary tables Object type Type of Comments 
 Discretes Input Single bit Read-Only This type of data can be provided by an I/O system. 
Coils Single bit Read-Write This type of data can be alterable by an application 
program. 
Input Registers 16-bit word Read-Only This type of data can be provided by an I/O system 
Holding Registers 16-bit word Read-Write This type of data can be alterable by an application 
program. 
Input DiscreteMODBUS accessDevice application memory
MODBUS SERVER DEVICEMODBUS Request Coils
Input Registers
Output Registers
Figure 5 MODBUS Data Model with 
separate blocks Device application memory
MODBUS SERVER DEVICEMODBUS RequestInput DiscreteMODBUS access
Coils
Input Registers
Output RegistersR
W
R
W
Figure 6 MODBUS Data Model with only 
1 block  
¾MODBUS Client
The MODBUS Client allows the user applic ation to explicitly control information 
exchange with a remote device. The 
MODBUS  Client builds a MODBUS request from 
parameter contained in a demand sent by the user application to the MODBUS Client 
Interface.  
The MODBUS Client uses a MODBUS transac tion whose management includes waiting 
for and processing of a MODBUS confirmation.  
¾MODBUS Client Interface
The MODBUS Client Interface provides an interface enabling the user application to 
build the requests for various MODBUS 
services including access to MODBUS 
application objects. The MODBUS Client in terface (API) is not part of  this 
Specification, although an example is described in the implementation model. 
¾MODBUS Server
On reception of a MODBUS request this modu le activates a local action to read, to 
write 
or to achieve some other actions. The pr ocessing of these actions is done totally 
transparently for the application programmer. The main MODBUS server functions are 
to wait for a MODBUS request on 502 TCP port, to treat this request and then to build a 
MODBUS response depending on device context. 
¾MODBUS  Backend Interface
The MODBUS Backend Interface is an interfac e from the MODBUS Server to the user 
application in which the application objects are defined. 
October 24, 2006 http://www.Modbus.org 8/46Informative Note: The Backend Interface is  not defined in this Specification Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 9/46•TCP Management layer
Informative Note: The TCP/IP discussion in th is Specification is based in part upon 
reference 
[2] RFC 1122 to assist the user in implementing the MODBUS Application 
Protocol Specification [1] over TCP/IP. 
One of the main functions of the messaging service is to manage communication 
establishment and ending and to manage  the data flow on established 
TCP 
connections. 
¾Connection Management
A communication between a client and server MODBUS Module requires the use of a 
TCP connection management module. It is in charge to manage globally messaging TCP connections.  
Two possibilities are proposed for the connection management. Either the user application itself manages TCP connections or the connection management is totally 
done by this module and therefore it is transparent for the user application. The last solution implies less flexibility.   
The listening TCP port 502 is reserved for MODBUS communications. It is 
mandatory to listen by default on that port. Ho wever, some markets or applications 
might require that another port is dedicated to MODBUS over TCP.  For that reason, it 
is highly recommended that the clients and the servers give the possibility to the user 
to parameterize the MODBUS over TCP port number. It is important to note that 
even if another TCP server port is configured for MODBUS service in certain 
applications, TCP server port 502 must still be available in addition to any application specific ports.   
¾Access Control Module
In certain critical contexts, accessibility to in ternal data of devices must be forbidden for 
undesirable hosts. That’s why a security mode  is needed and security process may be 
implemented if required. 
•TCP/IP Stack lay er
The TCP/IP stack can be parameterized in order to adapt the data flow control, the 
address management and the connection manageme nt to different constraints specific 
to a product or to a system. Generally the BSD 
socket interface is used to manage the 
TCP connections. 
 Resource management and Data flow control
In order to equilibrate inbound and outbound messaging data flow between theMODBUS client and the server, data flow cont rol mechanism is provided in all layers
of MODBUS messaging stack.
The resource management and flow control module  is first based on TCP internal flow
control added with some data flow control in the data link 
layer and also in the user
application level.Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 10/464.2 TCP CONNECTION MANAGEMENT 
4.2.1 Connections management Module  4.2.1.1 General description 
A MODBUS communication requires the establishment of a TCP connection between a 
Client and a Server.  
The establishment of the connection can be activated either explicitly by the User 
Application module or automatically by the TCP connection management module.  
In the first case an application-programming interface has to be provided in the user 
application module to manage completely the connection. 
This solution provides 
flexibility for the application programmer but it  requires a good expertise on TCP/IP 
mechanism. 
In the second case the TCP connection management is completely hidden to the user 
application that only sends and receives MODBUS messages. The TCP connection 
management module is in charge to estab lish a new TCP connection when it is 
required.  
The definition of the number of TCP client and server connections is not on the scope of 
this document (value n in this document).  Depending on the device 
capacities the 
number of TCP connections can be different. 
Implementation Rules : 
1) Without explicit user requirement, it is recommended to implement the automatic TCP
connection management
2) It is recommended to keep the TCP connection opened with a remote device and not
to open and close  it for each MODBUS/TCP transaction,
Remark: However the MODBUS client must be capable of accepting a close request
from 
the server and closing the connection. The connection can be reopened when
required.
3) It is recommended for a MODBUS Client to open a minimum of TCP connections with
a remote MODBUS server (with the same IP  address). One connection per application
could be a good choice.
4) Several MODBUS transactions can be ac tivated simultaneously on the same TCP
Connection.
Remark: If this is done then the MODBUS tr ansaction identifier must be used to
uniquely identify the matching requests and responses.
5) In case of a bi-directional communication between two remote MODBUS entities (
each of them is client and server), it is necessary to open separate connections for
the client data flow and for the server data flow.
6) A TCP frame must transport only one MODBUS ADU. It is advised against sending
multiple MODBUS requests or responses on the same TCP PDUModbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Idle
October 24, 2006 http://www.Modbus.org 11/46Connection_established
Request_treatmentWait
Oldest_unused_
connection_closed
Connection_establishmentConnection_accepted
Oldest_unused_no_prioritary_connection_closed
Active_Connection
network_transmissionWait
Request_treatmentConn ect
ion_establishedConnection_acceptedConnection_refused
Active_Connection
network_transmission[connection established]
[Connection OK][<n connections]
[Connection NOK][< n connections][access ctl][connection request]
[IP forbidden][data]
[no access ctl][______Event on a socket[Request to a remote
____
[IP authorized]
[n connections][n connections][else]Server Client 
Figure 7: TCP connection management activity diagram 
1.Explicit TCP connection management
The user application module is in charge of managing all the TCP connections: active 
and passive establishment, connection ending, etc. This management is done for 
all 
MODBUS communication between a client and a server. The BSD Socket interface is used in the user application module to manage the TCP connection. This solution offers 
a total flexibility but it implies that t he application programmer has sufficient TCP 
knowledge. 
A limit of number of client and server conne ctions has to be configured taking into 
account the device capabilities and requirement.  
2. Automatic TCP connection management
The TCP connection management is totally tran sparent for the user application module. 
The connection management module may accept a sufficient number 
of client and 
server connections. 
Nevertheless a mechanism must be implemented in case of exceeding the number of 
authorized connection. In such a case we recommend 
to close the oldest unused 
connection. 
A connection with a remote partner is estab lished at the first packet received from a 
remote client or from the local user application. This connection will be closed if a 
termination arrived from the network or decid ed locally on the device. On reception of a 
connection request, the access control option can be used to forbid device accessibility to unauthorized clients. Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
The TCP connection management module uses th e Stack interface (usually BSD Socket 
interface) to communicate with the TCP/IP stack. 
In order to maintain compatibility between system requirements and server resources, 
the TCP management will maintain 2 pools of connection. 
 The first pool ( priority  connection pool ) is made of connections that are never
closed on a local initiative. A configuration mu st be provided to set this pool up. The 
principle to be implemented is to associat e a specific IP address with each possible 
connection of this pool. The devices with such IP addresses are said to be “marked”. Any new connection that is re quested by a marked device must be 
accepted, and will be taken from the priority connection pool. It is also necessary to 
configure the maximum number of Connections allowed for each remote device to avoid that the same device uses all the connections of the priority pool.  
 The second pool ( non-priority
  connection pool ) contains connections for non
marked devices. The rule that takes over here is to close the oldest connection when a new connection request arrives from a non-marked device and when there is no more connection available in the pool. 
A configuration might be optionally provided  to assign the number of connections 
available in each pool. However (It is not mandatory) the designers can set the number of connections at design time if required. 
4.2.1.2 Connection management description 
•Connection establishment :
The MODBUS messaging service must provide a listening socket on Port 502, which 
permits to accept new connection and to exchange data with other devices.  
When the messaging service needs to exchange  data with a remote s e rver, it must 
open a new client connection with a remote Port 502 in order to exchange data with this distant. The local port must be higher than 1024 and different for each client connection. 
Device Device
Client
Ports
Server
Port502n
(n>1024)
Server
PortClient
Ports
502n
(n>1024) Connection (@ IP1 n,
@IP2 502)@ IP1 @ IP2
Figure 8: MODBUS TCP connection establishment 
If the number of client and server connections is greater than the number of authorized connections the oldest unused connection is closed. The access control mechanism can be activated to check if the IP address of the remote client is authorized. If not the 
new connection is refused. 
October 24, 2006 http://www.Modbus.org 12/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 13/46•MODBUS data transfer
A MODBUS request has to be sent on the righ t TCP connection already opened. The IP 
address of the remote is used to find the TCP connection. In case of multiple TCP 
connections opened with the same remote, one connection has to be chosen to send the MODBUS message, different choice criteria can be used like the oldest one, the first one. The connection has to maintain open during all the MODBUS communications. As described in the following sections a client can initiate several MODBUS transactions with a server without wait ing the ending of the previous one.  
Connection closing
When the MODBUS communications are ended between a Client and a Server, the client has to initiate a connection clos ing of the connection used for these 
communications.  
4.2.2 Impact of Operating Modes on the TCP Connection 
Some Operating Modes (communication br eak between two operational End Points, 
Crash and Reboot on one of the End Point, …) may have impacts on the TCP Connections. A connection can be seen closed or aborted on one side without the 
knowledge of the other side. The connection is said to be " half-open" . 
This section describes the behavior for each main Operating Modes. It is assumed 
 that 
the Keep Alive  TCP mechanism is used on both end points (See section 4.3.2) 
4.2.2.1 Communication break between two operational end points: 
The origin of the communication break can be  the disconnection of the Ethernet cable 
on the Server side. The expected behavior is: 
•If no packet is currently sent on the connection:
The communication break will not be seen if it lasts less than the Keep Alive timer 
value. If the communication break lasts more than the Keep Alive timer value, an error is returned to the TCP Management layer that can reset the connection. 
•If Some packets are sent before and after the disconnection:
The TCP retransmission algorithms (Jacobson's , Karn's algorithms and exponential 
backoff. See section 4.3.2) are activated. This may lead to a stack TCP layer Reset of the Connection before the Keep Alive timer is over. 
4.2.2.2 Crash and Reboot of the Server end point 
After the crash and Reboot of the Server, the connection is "half-open" on Client side. 
The expected behavior is: 
• If no packet is sent on the half-open connection:
The TCP half-open connection is seen opened from the Client side as long as the Keep Alive timer is not over. After that an error is returned to the TCP Management 
layer that can reset the connection. 
•If some packets are sent on the half-open connection:
The Server receives data on a connection that doesn't exist anymore. The stack TCP layer sends a Reset to close the half-open connection on the Client side 
4.2.2.3 Crash and Reboot of the Client 
After the crash and Reboot of the Client, the connection is "half-open" on Server side. 
The expected behavior is: Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 14/46•No packet is sent on the half-open connection:
The TCP half-open connection is seen opened from  the Server side as long as the
Keep Alive timer is not over. After that an error is returned to the TCP Management
layer that can reset the connection.
•If the Client opens a new connection bef ore the Keep Alive timer is over :
Two cases have to be studied:
The connection opening has the same characteristics as the half-open
connection  on the server side (same source and destination Ports, same source
and destination IP Addresses), therefore the connection opening will fail at the
TCP stack level after the Time-Out on Conn ection Establishment (75s on most of
Berkeley implementations). To avoid this long Time-Out during which it is not
possible to communicate, it is advised to ensure that different source portnumbers than the previous one are used for a connection opening after a reboot
on the client side.
The connection opening has not the same characteristics as the half-open
connection  on the server side (different sour ce Ports, same destination Port,
same source and destination IP Address ),  therefore the connection is opened at
the stack TCP level and signaled to the Server TCP Management layer.
If the Server TCP Management layer only su pports one connection from a remote
Client IP Address, it can close the 
old half-opened connection and use the new
one.
If the Server TCP Management layer suppor ts  several connections from a remote
Client IP Address, the new connection stays opened and the old one also stays
half-opened until the expiration of the Keep A live Timer that will return an error to
the TCP Management layer. After that the TCP Management layer will be able to
Reset the old connection.
4.2.3 Access Control Module 
The goal of this module is to check every ne w connection and using a list of authorized 
remote IP addresses the module can authorize or forbid a remote Client TCP 
connection. 
In 
critical context the application progra mmer needs to choose the Access Control 
mode in 
order to secure its network access. In such a case he needs to Authorize/forbid 
access for each remote @IP. The user needs to provide a list of IP addresses and to 
specify for each IP address if it’s authorized or  not. By default, on security mode, the IP 
addresses not configured by the user are forb idden. Therefore with the access control 
mode a connection coming from an unknown IP address is closed. 
4.3 USE of TCP/IP STACK  
A TCP/IP stack provides an interface to manage  connections, to send and receive data, 
and also to do some parameterizations in order to adapt the stack behavior to the device or system constraints.  Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Network AccessNetwork Access
Ethernet II and 802.3 layerEthernet II and 802.3 layer  MsgMsg
TCPTCPModbusModbus
IPIPICMPICMP
ARPARPThe goal of this section is to give 
an overview of the Stack interface and also some information concerning the parameterization of the stack. This overview focuses on the features used by the MODBUS Messaging.  
For more information, the advice is to read the RFC 1122 that provides guidance for 
vendors and designers of Internet communication software. It enumerates standard protocols that a host connected to the Internet  must use as well as an explicit set of 
requirements and options. 
The stack interface is generally based on the BSD (Berkeley Software Distribution) 
Interface that is described in this document. .  
4.3.1 Use of BSD Socket interface 
Remark : some TCP/IP stacks propose othe r types of interfaces for perform ance 
issues. A MODBUS client or server can use these specific interfac es, but this use will 
be not described in this specification. 
A socket is an endpoint of communication. It is the basic building block for 
communication. A MODBUS communication is executed by sending and receiving data 
through sockets. The TCPIP 
library provid es only stream sockets using TCP and 
providing a connection-based communication service. 
The Sockets are created via the socket ()  func tion. A socket number is returned, which 
is then used by the creator to access the socket. Sockets are created without addresses (IP address and port number). Until a port is bound to a socket, it cannot be 
used to receive data.   
The bind ()  function is used to bind a port number to a socket. The 
 bind () creates an 
association between the socket and the port number specified.  
In order to initiate a connection, the client must issue the connect ()  function specifying 
the 
socket number, the remote IP address and the remote listening port number (active 
connection establishment). In order to complete a connection, the server must issue the accept ()  func
 tion 
specifying the socket number that was specified in the prior listen () call (passive 
connection establishment). A new socket is cr eated with the same properties as the 
initial one. This new socket is connected to the client’s socket, and its number is returned to the server. The initial socket is thereby free for other clients that might want to connect with the server. 
After the establishment of the TCP connec tion the data can be transferred. The send()  
and recv() functions are designed specifically to be  used with sockets that are already 
connected. 
The setsockopt ()  f unction allows a socket’s creator to associate options with a socket. 
These options modify the behavior of the so cket. The description of these options is 
given in the section 4.3.2. 
The select ()  func tion allows  the programmer to test events on all sockets. 
October 24, 2006 http://www.Modbus.org 15/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 16/46The shutdown ()  function allows a socket user to disable send () and/or receive () on 
the socket. 
Once a socket is no longer needed, its socket descriptor can be discarded by using the 
close ()  func
tion. 
Figure 39: MODBUS Exchanges describes a full MODBUS communication between a 
client and a s server. The Client establishes the connection and sends 3 MODBUS 
requests to the server without waiting the re sponse of the first one. 
After receiving all 
the responses the Client clos es the connection properly.  Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
CLIENT
( IP1)
fd=socket()
bind(fd,n)
connect(fd,IP2,502)
send(fd)SERVER
(IP2)
fd'=socket()
bind(fd',502)
listen(fd')
fd''=accept(fd')
recv(fd'')
MODBUS Request PDU 1MODBUS Request PDU isend(fd)
recv(fd'')
send(fd")MODBUS Respons e PDU 1recv(fd)
MODBUS Request PDU Nsend(fd)
MODBUS Response PDU irecv(fd)recv(fd'')
MODBUS Response PDU  Nrecv(fd)send(fd")
send(fd")
close(fd)
close(fd")SYN J
SYN K, ACK J+1
ACK K+1
FIN
ACK of FIN
FIN
ACK of FIN
Figure 9: MODBUS Exchanges 
October 24, 2006 http://www.ModbusA.org 17/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 18/464.3.2 TCP  layer parameterization 
Some parameters of the TCP/IP stack can be adjusted to adapt its behavior to the 
product or system constraints. The following parameters can be adjusted in the TCP 
layer: 
•Parameters for each connection:
SO-RCVBUF, SO-SNDBUF:  
These parameters allow setting the high water mark for the Send and the Receive Socket. They can be adjusted for flow control management. The 
size of the received 
buffer is the maximum size advertised window for that connection. Socket buffer sizes must be increased in order to increase performances. Nevertheless these values must be smaller than internal driver resources in order to close the TCP window before exhausting internal driver resources.  
The received buffer size depends on the TCP Windows size, the TCP Maximum 
segment size and the time needed to absorb the incoming frames. 
With a Maximum 
Segment Size of 300 bytes (a MODBUS requ est needs a maximum of 256 bytes + the 
MBAP header size), if we need 3 frames buffering, the socket buffer size value can be adjusted to 900 bytes. For biggest needs and best-scheduled time, the size of the TCP window may be increased.  
TCP-NODELAY:
 
Small packets (called tinygrams) are normally not a problem on LANs, since most LANs 
are not congested, but these tinygrams can lead to congestion on wide 
area networks. 
A simple solution, called the "NAGLE algorithm" , is to collect small amounts of data and 
sends them in a single segment when TC P acknowledgments of previous packets 
arrive.  
In order to have better real-time behavior it is recommended to send small amounts of 
data directly without trying to gather them in a single segment. That is why it is 
recommended to force the TCP-NODELAY option  that disables the 
"NAGLE algorithm" 
on client and server connections.  
SO-REUSEADDR:  
When a MODBUS server closes a TCP connec tion initialized by a remote client, the 
local port number used for this connection cannot be reused for a new 
opening while 
that connection stays in the "Time-wait " state (during two MSL : Maximum Segment 
Lifetime). 
It is recommended specifying the SO-REUSEADDR option for each client and server 
connection to bypass this restriction. This op tion allows the process to assign itself a 
port number that is part of a connection that is in the 2MSL wait 
for client and listening 
socket. 
SO-KEEPALIVE:  
By default on TCP/IP protocol no data ar e sent across an idle TCP connection. 
Therefore if no process at the ends of a TC P connection is 
sending data to the other, 
nothing is exchanged between the two TCP modules. This assumes that either the 
client application or the server application uses  timers to detect inactivity in order to 
close a connection. 
It is recommended to enable the KEEPALIVE option on both client and server 
connection in order to poll the other end to know if the distant has either crashed and 
is 
down or crashed and rebooted. 
Nevertheless we must keep on mind that enabling KEEPALIVE can cause perfectly 
good connections to be dropped during transient failures, that it consumes unnecessary 
bandwidth on the network if the keep alive timer is too short. Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
•Parameters for the whole TCP layer:
Time Out on establishing a TCP Connection:  
Most Berkeley-derived systems set a time limit  of 75 seconds on the establishment of a 
new connection, this default value should be adap ted to the real time constraint of the 
application. 
Keep Alive parameters:  
The default idle time for a connection is 2 hours. Idles times in excess of this value 
trigger a keep alive probe. After the first ke ep alive probe, a probe is sent every 75 
seconds for a maximum number of times unless a probe response is received. 
The maximum number of keep Alive probes sent out on an idle connection is 8. If no 
probe 
response is received after sending out the maximum number of keep Alive 
probes,TCP signals an error to the application that can decide to close the connection  
Time-out and retransmission parameters:
A TCP packet is retransmitted if its loss has been detected. One way to detect the loss 
is to manage a Retransmission Time-Out (RTO) that expires if no acknowledgement has been received from the remote side.  
TCP manages a dynamic estimation of the RTO.  For that purpose a 
 Round-Trip Time 
(RTT) is measured after the send of every packet that is not a retransmission. The 
Round-Trip Time (RTT) is the time taken for a packet to reach the remote device and to 
get back an acknowledgement to the sending device. The RTT of a connection is calculated dynamically, nevertheless if TCP ca nnot get an estimate within 3 seconds, 
the default value of the RTT is set to 3 seconds. 
If the RTO has been estimated, it applies to the next packet sending. If the acknowledgement of the next packet is not received before 
the estimated RTO 
expiration, the Exponential BackOff  is activated. A maximum number of 
retransmissions of the same packet is allowe d during a certain amount of time. After 
that if no acknowledgement has been rece ived, the connection is aborted.  
The maximum number of retransmissions and the maximum amount of time before the abort of the connection (tcp_ip_abort_interval) can be set up on some stacks. 
Some retransmission algorithms are defined in TCP standards :  
The Jacobson's RTO estimation algorithm  is  used to estimate the
Retransmission Time-Out (RTO),
The Karn's algorithm  says  that the RTO estimation should not be done on a
retransmitted segment,
 The Exponential BackOff  defines that the retransmission time-out is doubled for
each retransmission with an upper limit of 64 seconds.
The fast retransmission algorithm  allows retrans mitting after the reception of
three duplicate acknowledgments. This algo rithm is advised because on a LAN it
may lead to a quicker detection of the loss of a packet than waiting for the RTO
expiration.
The use of these algorithms is recommended for a MODBUS implementation.  
4.3.3 IP layer parameterization 
4.3.3.1 IP Parameters 
The following parameters must be configured in the IP layer of a MODBUS 
implementation : 
•Local IP Address : the IP address can be part of a Class A, B or C.
•Subnet Mask, : Subnetting an IP Network can be done for a variety of reasons : use of
different physical media (such as Ethernet, WAN, etc.), more efficient use of 
October 24, 2006 http://www.Modbus.org 19/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
network addresses, and the capability to control network traffic. The Subnet Mask 
has to be consistent with the IP addr ess class of the local IP address. 
• Default Gateway:  The IP address of the default gateway has to be on the same
subnet as the local IP address. The value 0.0. 0.0 is forbidden. If no gateway is to be 
defined then this value is to be set to eith er 127.0.0.1 or the Local IP address. 
Remark : The MODBUS messaging service doesn' t require the fragmentation function in 
the IP layer. 
The local IP End Point shall be configured with a local IP Address  and with a Subnet 
Mask and a Default Gateway  (different from 0.0.0.0) . 
4.4 COMMUNICATION APPLICATION LAYER 
4.4.1 MODBUS Client 
Modbus
Client
TCP/IP
Modbus
Server
TCP/IPModbus
Server
TCP/IPModbus
Server
Serial LineModbus
Server
Serial LineModbus
Client
Serial Line
Modbus
Client
TCP/IP
Modbus TCP / IPClient TCP/IP
gateway
Server TCP/IP
gateway
Modbus Serial line
Figure 10: MODBUS Client unit 
4.4.1.1 MODBUS client design 
The definition of the MODBUS/TCP protocol allows a simple design of a client. The 
following activity diagram describes the main treatments that are processed by a client 
to send a MODBUS request and to treat a MODBUS response. 
October 24, 2006 http://www.Modbus.org 20/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Send negative
confirmation to user
ApplicationProcess
MODBUS
Confirmation
Set Waiting
response timerSend MODBUS request
To TCP managementWait
Find out pending
transactionIdle
Send positive
confirmation toUser ApplicationBuild MODBUSrequestWaitIdle
[Retries number reached][Request_from_the_user application]
[Confirmation error]Waiting_response_timer_expires[Reveive_Response_from_TCP_Mgt]
[Retries number not reached]
[Confirmation OK]
[Send Not OK] [Send OK]
Figure 11: MODBUS Client Activity Diagram 
A MODBUS client can receive three events:  
A new demand from the user application to  send a request , in this case a MODBUS
request has to be encoded and be sent on the network using the TCP management component service. The lower layer ( TCP management module) can give back an error due to a TCP connection error, or some other errors. 
 A response from the TCP management, in th is 
 case the client has to analyze the
content of the response and send a conf irmation to the user application 
The expiration of a Time out due to a non-response. A new retry can be sent on the
network or a negative confirmation can be  sent to the User Application. 
Rem
ark : These retries are initiated by the MODBUS client, some other retries can 
also be done by the TCP layer in case of TCP acknowledge lack. 
4.4.1.2 Build a MODBUS Request 
Following the reception of a demand from the user  application, the client has to build a 
MODBUS request and to send it  to the TCP management.  
Building the MODBUS request can be split in several sub-tasks:  
The instantiation of a MODBUS transaction that enables the Client to memorize all
required information in order to bind later the response to the request and to send the confirmation to the user application. 
The encoding of the MODBUS request (PDU + MPAB header). The user application
that initiates the demand has to provide a ll required information which enables the 
Client to encode the request. The MODBUS PDU is encoded according to 
the 
MODBUS Application Protocol Specificat ion [1]. (MB function code, associated 
parameters and application data ). All fiel ds of the MBAP header are filled. Then, 
the MODBUS request ADU is built pref ixing the PDU with the MBAP header 
October 24, 2006 http://www.Modbus.org 21/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
The sending of the MODBUS request ADU to the TCP management module which is
in charge of finding the right TCP socket to wards the remote Server. In addition to 
the MODBUS ADU the Destination IP address must also be passed. 
The following activity diagram describes, more deeply than in Figure 11 MODBUS 
Client Activity Diagram, the request building phase. 
Instantiate a MB 
transaction
Initialize the transaction
Send MB request to TCP Mgt Send a negative confirmation to the user applicationEncode the MB request PDU 
Encode the MBAP header[No Transaction available]
[Transaction available]
Figure 12: Request building activity diagram 
The following example describes the MODBUS request ADU encoding for reading the 
register # 5 in a remote server : 
♦MODBUS Request ADU encoding :
Description Size Example 
Transaction Identifier  Hi 1 0x15 
Transaction Identifier  Lo 1 0x01 
Protocol Identifier 2 0x0000 
Length 2 0x0006MBAP Header  
Unit Identifier 1 0xFF 
October 24, 2006 http://www.Modbus.org 22/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 23/46Function Code (*) 1 0x03 
Starting Address 2 0x0004 MODBUS 
request 
Quantity of Registers 2 0x0001 
(*) please see the MODBUS Applic ation Protocol Specification [1]. 
•Transaction Identifier
The transaction identifier is used to associate the future response with the request.
So, at a time, on a TCP connection, this identifier must be unique. There are
several manners to use the transaction identifier:
-For example, it can be used as a simple "TCP sequence number" with a
counter which is incremented at each request.
-It can also be judiciously used as a sm art index or pointer to identify a
transac
tion context in order to memorize the current remote server and the
pending MODBUS request.
Normally, on MODBUS serial line a client mu st send one request at a time. This means 
that the client must wait for the answer to the first request before sending a second 
request. On TCP/MODBUS, several requests can be sent without waiting for a confirmation to the same server.  The MODB US/TCP to MODBUS serial line gateway is 
in charge of ensuring compatibility between these two behaviors.   
The number of requests accepted by a serv er depends 
 on its capacity in term of 
number of resources and size of the TCP wi ndows. In the same way the number of 
transactions initialized simultaneously by a cli ent depends also on its resource capacity. 
This implementation parameter is called " NumberMaxOfClientTransaction " and must 
be described as one of the MODBUS client fe atures. Depending of the device type this 
parameter can take a value from 1 to 16.  
•Unit Identifier
This field is used for routing purpose when addressing a device on a MODBUS+
or MODBUS se
rial line sub-network. In that case, the “Unit Identifier” carries the 
MODBUS slave address of the remote device: 
If the MODBUS server is connected to a MODBUS+ or MODBUS Serial Line 
sub-network and 
addressed through a bridge or a gateway, the MODBUS Unit 
identifier is necessary to identify th e slave device connected on the sub-
network behind the bridge or the gateway. The destination IP address identifies the bridge itself and the bridge  uses the MODBUS Unit identifier to 
forward the request to the right slave device. 
The MODBUS slave device addresses on serial line are assigned from 1 to 
247 (decimal). Address 0 is used as broadcast address. 
On TCP/IP, the MODBUS 
server is addresse d using its IP address; therefore, the 
MODBUS Unit Identifier is useless.  The value 0xFF has to be used. 
When addressing a MODBUS server connec ted directly to a TCP/IP network, 
it’s recommended not using a significant MODBUS 
slave address in the “Unit 
Identifier” field. In the event of a re-allo cation of the IP addresses within an 
automated system and if a IP address previously assigned to a MODBUS 
server is then assigned to a gateway, using a significant slave address may 
cause trouble because of a bad routing by the gateway. Using a non-significant slave address, the gateway will simply discard the MODBUS PDU 
with no trouble. 0xFF is recommended for the “Unit Identifier" as non-significant value. 
Remark : The value 0 is also accepted to communicate directly to a 
MODBUS/TCP device . Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 24/464.4.1.3 Process MODBUS Confirmation 
When a response frame is received on a TC P connection, the Transaction Identifier 
carried in 
the MBAP header is used to associate the response with the original request 
previously sent on that TCP connection: 
 If the Transaction Identifier doesn't refer to any MODBUS pending transaction, the
response must be discarded. 
 If the Transaction Identifier refers to a MODBUS pending transaction, the response
must be 
parsed in order to send a MODBUS Confirmation to the User Application 
(positive or negative confirmation) 
Parsing the response consists in verify ing the MBAP Header and the MODBUS PDU 
response: 
MBAP Header
After the verification of the Protocol Identif ier that must be 0x0000, the length gives 
the size of the MODBUS response. 
If the response comes from a MODBUS serv er device directly connected to the 
TCP/IP 
network, the TCP connection identification is sufficient to unambiguously 
identify the remote server. Therefore, the Unit Identifier carried in the MBAP 
header is not significant (value 0xFF) and must be discarded. If the remote server is connected on a Serial Line sub-network and the response 
comes from a bridge, a router or 
a gateway,  then the Unit Identifier (value != 0xFF) 
identifies the remote MODBUS server which has originally sent the response. 
MODBUS Response PDU
The function code must be verified and the MODBUS response format analyzed according to the MODBUS Application Protocol: 
•if the function code is the same as the one used in the 
 request, and if the
response format is correct, then the MODBUS response is given to the user
application as a Positive Confirmation .
•If the function code is a MODBUS exception code (Function code + 80H), the
MODBUS exception response is give n to the user application as a Positive
Confirmation.
•If the function code is different from  the one used in the request (=non
expected function code), or if the format  of the response is incorrect, then an
error is signaled to the user application using a Negative Confirmation .
Remark: A positive confirmation is a confirmation that the command was received and 
responded to by the server. It does not imply that the server was able to successfully act on the command (failure to successfully act on the command is indicated by the MODBUS Exception response). 
The following activity diagram describes, more deeply than in Figure 11 MODBUS 
Client Activity Diagram, the confirmation processing phase. Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Use MB transaction to 
bind with the re quest
Process_M B_exceptionFind Out pending MB transaction
Extract MB ResponseDiscard 
Response
Analyse MBAP header
Analyse Response 
PDU
WaitSend positive confirmation to user 
applicationSend negative 
Confirmation to user Application
Wait[Modbus_protocol][No Pending Transaction ]
[Incorrect Response][Other_protocol]
[MB Exception response][MB response OK][PendingTransaction ]
Figure 13: Process MODBUS Confirmation activity diagram 
4.4.1.4 Time-out management 
There is deliberately NO specification of requ ired response time for a transaction over 
MODBUS/TCP.  
This is because MODBUS/TCP is expected to be used in the widest possible variety of 
communication situations, from I/O scanners expecting sub-millisecond timing to long 
distance radio links with delays of several seconds. 
From a client perspective, the timeout must take into account the expected transport 
delays across the network, to determine a ‘reasonable’ response time. 
Such transport 
delays might be milliseconds for a switched Et hernet, or hundreds of milliseconds for a 
wide area network connection. 
In turn, any ‘timeout’ time used at a client to  initiate an application retry should be 
larger than the expected maximum ‘reasonable’ response time. If this is 
not followed, 
there is a potential for excessive congestion at  the target device or on the network, 
which may in turn cause further errors. This is a characteristic, which should always be 
avoided. 
October 24, 2006 http://www.Modbus.org 25/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
So in practice, the client timeouts used in high performance applications are always 
likely to be somewhat dependent on network topo logy and expected client performance. 
Applications which are not time critical c an often leave timeout values to the normal 
TCP defaults, which will report communication failure after several seconds on most 
platforms. 
4.4.2 MODBUS Server 
Modbus
Client
TCP/IP
Modbus
Server
TCP/IPModbus
Server
TCP/IPModbus
Server
Serial LineModbus
Server
Serial LineModbus
Client
Serial Line
Modbus
Client
TCP/IP
Modbus TCP / IPClient TCP/IP
gateway
Server TCP/IP
gateway
Modbus Serial line
Figure 14: MODBUS Server unit 
The role of a MODBUS server is to provid e access to application objects and services 
to remote MODBUS clients. 
Different kind of access may be provided depending on the user application : 
simple access like get and set application objects attributes
advanced access in order to trigger specific application services
The MODBUS server has: 
To map application objects onto readable an d writable MODBUS objects, in order
to get or set applicati on objects attributes.
To provide a way to trigger services onto application objects.
In run time the MODBUS server has to  analyze a received MODBUS request, to 
process the required action, and to send back a MODBUS response. Informative Note:  The application objects and se
 rvices of the Backend Interface obtain 
the requested data based upon the function code, and the User is responsible.  
October 24, 2006 http://www.Modbus.org 26/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
4.4.2.1 MODBUS Server Design 
The MODBUS Server design depends on both : 
the kind of access to the application objects (simple access to attributes or
advanced access to services)
the kind of interaction between the MO DBUS server and the user application
(synchronous or asynchronous).
The following activity diagram describes the main treatments that are processed by the 
Server to obtain a MODBUS request from TCP Management, then to analyze the 
request, to process the required action, and to send back a MODBUS response. 
Build a MODBUS
responseWait
MODBUS_PDU_Checking...Idle
Build a MODBUSException
Send responseto TCP_MgtMODBUS_Service_ProcessingInvoke backend interface
Response
processing
Release the
MODBUS server
transactionWait
MODBUS_PDU_Checking...
[Processing OK] [Processing OK][Need user application processing][Server init]
[Reception of a MODBUS indication
from TCP Mgt][Response from user application]
[MODBUS transaction accepted][MB transaction refused][MB Indication discarded][Invocation user application done]
[Processing not OK][Processing not complete]
[MB Exception OK]
[processing ends][Processing not OK]
[MB Response OK]
Figure 15: Process MODBUS Indication activity diagram 
October 24, 2006 http://www.Modbus.org 27/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 28/46As shown in the previ ous activity diagram: 
Some services can be immediately proce ssed by the MODBUS Server itself, with
no direct interaction with the User Application ;
Some services may require also interactin g explicitly with the User Application to
be processed ;
Some other advanced services require invoking a specific interface called
MODBUS Back End service. For example, a User Application service may be
triggered using a sequence of several MODBUS request/response transactions
according to a User Application level protocol. The Back End service is
responsible for the correct processing of all individual MODBUS transactions inorder to execute the global User Application service.
A more complete description is given in the following sections. 
The MODBUS server can accept to serve simultaneously several MODBUS requests. 
The maximum number of simultaneous MODBUS requests the server can accept is one of the main characteristics of a MODBUS se rver. This number depends on the server 
design and its processing and memory capabilities. This implementation parameter is 
called " NumberMaxOfSeverTransaction " and must be described as one of the 
MODBUS server features. It may have a value from 1 to 16 depending on the device 
capabilities.  
The behavior and the performance of the MODBUS  server are significantly affected by 
the "NumberMaxOfTransaction" parameter. Partic ularly, it's important to note that the 
number of concurrent MODBUS transactions managed may affect the response time of 
a MODBUS request by the server. 
4.4.2.2 MODBUS PDU Checking 
The following diagram describes the MODBUS PDU Checking activity.  Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
Parse the
MBAP header
Instantiate aMB TransactionMB Indicationdiscarded
MB Transaction
refused
MB Transaction
acceptedParse The MBPDU[MBAP OK]
[Transaction available]
[OK][No Transaction available]
[Error on MB PDU][Error on MBAP ]
Figure 16: MODBUS PDU Checking activity diagram 
The MODBUS PDU Checking function consists of first parsing the MBAP Header. The 
Protocol Identifier field has to be checked :  
If it is  different from MODBUS protocol type, the indication is simply discarded.
If it is correct (= MODBUS protocol type; value 0x00), a MODBUS transaction is
instantiated.
The maximum number of MODBUS transactions th e server can instantiate is defined by 
the "NumberMaxOfTransaction" parameter ( A system or a configuration parameter). 
In case of no more transactions availabl e, the server builds a MODBUS exception 
response (Exception code 6 : Server Busy). 
If a MODBUS transaction is available, it's in itialized in order to memorize the following 
information:  
•The TCP c onnection identifier used to send the indication (given by the TCP
Management)
•The MODBUS Trans action ID (given in MBAP Header)
•The Unit Identifier (given in MBAP Header)
Then the MODBUS PDU is parsed.  The function code is first controlled :  
in case of invalidity a MODBUS exception re sponse is built (Exception code 1 : Invalid
function). 
 If the function code is accepted, the server initiates the "MODBUS Service
proces
sing" activity. 
October 24, 2006 http://www.Modbus.org 29/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
4.4.2.3 MODBUS service processing 
Analyse
requested service
Local Service
processing
Build ModbusResponseBuild ModbusException ResponseSend an invocation to
User Application
through MB Backend
interfaceResponseprocessing
[Need User App processing]
[Completed][Local processing ]Transaction_accepted
[Processing OK][Processing not completed]
[Processing  not OK]Response_from_user_App
[Processing OK]
[Processing Not OK]
Figure 17: MODBUS service processing activity diagram 
The processing of the required MODBUS service can be done in different ways 
depending on the device software and hardware architecture as described in the hereafter examples :  
•Within a compact device or a mono-th read architecture where the MODBUS
server can access direct
ly to the user ap plication data, the required service can
be processed "locally" by the server itse lf without invoking the Back End service.
The processing is done according to the MODBUS Application Protocol
Specification [1]. In case of an error, a MODBUS exception response is built.
•Within a modular multi-processor device or  a multi-thread architecture where the
"communication layers" and the "user applic ation layer" are 2 separate entities,
some trivial services can be processed co mpletely by the Communication entity
while some others can require a cooperat ion with the User Application entity
using the Back End service.
To interact with the User Application, the MODBUS Backend service must implement all appropriate mechanisms in order to handle User Application transactions and to 
manage correctly the User Application invocations and associated responses. 
4.4.2.4 User Application Interface (Backend Interface) 
Several strategies can be implemented in the MODBUS Backend service to achieve its 
job although they are not equivalent in te rms of user network throughput, interface 
bandwidth usage, response time, or even design workload. 
October 24, 2006 http://www.Modbus.org 30/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 31/46The MODBUS Backend service will use the appropriate interface to the user 
application : 
Either a physical interface based on a seri al link, or a dual-port RAM scheme, or
a simple I/O line, or a logical interface based on messaging services provided by
an operating system.
The interface to the User Applicati on may be synchronous or asynchronous.
The MODBUS Backend service will also use the appropriate design pattern to get/set objects attributes or to trigger services. In some cases, a simple "gateway pattern" will be adequate. In some other cases, the designer will have to implement a "proxy pattern" with a corresponding caching strategy, from a simple exchange table history to more sophisticated replication mechanisms. 
The MODBUS Backend service has the resp onsibility to implement the protocol 
transcription in order to interact with the Us er Application. Therefore, it can have to 
implement mechanisms for packet fragmentation/reconstruction, data consistency 
guarantee, and synchronization whatever is required. 
4.4.2.5 MODBUS Response building 
Once the request has been processed, the MO DBUS  server has to build the response 
using the adequate MODBUS server transact ion and has to send it to the TCP 
management component. 
Depending on the result of the processing two types of response can be built :  
A positive MODBUS response :
The response function code = The request function code
A MODBUS Exception response :
The objective is to provide to the client relevant information concerning the
error detected during the processing ;
The response function code = the request function code + 0x80 ;
The exception code is provided to indicate the reason of the error.
Exception 
Code MODBUS name Comments 
01 Illegal Function 
Code The function code is unknown by the server 
02 Illegal Data 
Address Dependant on the request 
03 Illegal Data Value Dependant on the request 
04 Server Failure The server failed during the execution 
05 Acknowledge The server accepted the service invocation but the 
service requires a relatively long time to 
execute. The 
server therefore returns onl y an acknowledgement of the 
service invocation receipt. 
06 Server Busy The server was unabl e to accept the MB Request PDU. 
The client application has the responsibility of deciding if 
and when to re-send the request. 
0A Gateway problem Gateway paths not available. 
0B Gateway problem The targeted devic e failed to respond. T he gateway 
generates this exception 
The MODBUS response PDU must be prefixed with the MBAP header which is built 
using data memorized in the transaction context. 
•Unit Identifier
The Unit Identifier is copied as it was gi ven within the received MODBUS request
and memorized in the transaction context.Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
•Length
The server calculates the size of the MODBUS PDU plus the Unit Identifier byte.
This value is set in the "Length" field.
•Protocol Identifier
The Protocol Identifier field is set to 0x 0000 (MODBUS protocol), as it was given
within the received MODBUS request.
•Transaction IdentifierThis field is set to the "Transaction Identif ier" value that was associated with the
original request and memorized in the transaction context.
Then the MODBUS response must be returned to the right MODBUS Client using the 
TCP connection memorized in the transaction context. When the response is sent, the 
transaction context must be free. 
5 IMPLEMENTATION GUIDELINE 
The objective of this section is to propose an example of a messaging service 
implementation.  
The model describes below can be used as a guideline during a client or a server 
implementation of a MODBUS messaging service. 
Informative Note:  The messaging service implementation is the responsibility of the User. 
5.1 OBJECT MODEL DIAGRAM 
Communication application layer
TCP managementConfiguration layerInterfaceUserApplication
InterfaceIndicationMsg InterfaceResponseMsgUser Application
Figure 18: MODBUS Messaging Service Object Model Diagram  
October 24, 2006 http://www.Modbus.org 32/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 33/46Four main packages compose the Object Model Diagram: 
•The Configuration lay e r which configures and manages operating modes of
components of other packages
•The TCP Management  which interfaces the TCP/IP stack and the communication
application layer managing TCP connection. It implies the management of socket
interface.
•The Communication application lay er which is composed by the MODBUS client
on one side and the MODBUS server on the other side. This package is linked
with the user application.
The User application, which corresponds to the device application, is completely dependent 
on  the device and therefore it will be not part of this Specification.  
This model is independent of implementation choices like the type of OS, the memory 
management, etc.  In order to guarantee this independence generic Interface layers 
are 
used between the TCP management layer and the communication layer and between 
the communication layer and the user application layer. 
Different implementations of this interface can be realized by the User: Pipe between 
two tasks, shared memory, serial link interface, procedural call, etc. 
Some assumptions  have to be  taken to define the hereafter implementation model : 
•Static memory management
•Synchronous treatment of the server
•One task to process the receptions on all sockets.
5.1.1 TCP management package Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
-----------------------------------------------------------------------------------------------------------------------------------------------
TCP manage ment 
packageInterfaceIndicationMsg
(from Logical View)InterfaceResponseMsg
(from Logical View)
ItemConnexion
SocketDescript : Int
IPSource : Long
PortSource : Long
PortDest : Long
IPdestination : long
BufferIn : Char*
BufferOut : Char*ConnexionMgt
NbConnectionSupported : Int
NbLocalConnection : Int
NbRemoteConnection : int
m_sendData()
m_Receivedata()
m_isConnectionAuthorized()InterfaceConnexion
GetObjectConnexion()
FreeObjectConnexion()
RetreivingObjectConnexion()
MBAP
IsMdbHeader()
GetMessagelength()
WriteTransactionId()
ReadTransactionId()TCPConnexion
IsConnexionRequest()
OpenConnexion()
AcceptConnexion()
CloseConnexion()
IsEtablishedConnexion()
StackTCP IP
Socket interface()
Figure 19: MODBUS TCP management package 
The TCP management package comprises the following classes :  
CInterfaceConnexion: The role of this class consists in managing memory pool for 
connections.  
CItemConnexion: This class contains all information needed to describe a connection. CTCPConnexion :, This class provides methods for managing automatically a TCP 
connection (Interface socket is provided by CStackTCP_IP ). 
CConnexionMngt : This 
 class manages all connections and send query/response to 
MODBUS Server/MODBUS Client through CinterfaceIndicationMsg and 
CInterfaceResponseMsg . This class also treats the Access control for the connection 
opening. 
CMBAP : This class provides methods for re ading/writing/analyzing the MODBUS 
MBAP. 
CStackTCP_IP: This class  Implements  socket services and provides parameterization 
of the stack. 
October 24, 2006 http://www.Modbus.org 34/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
5.1.2 Configuration layer package 
Operating Mode
m_Configure()
m_Start()
m_Stop()
m_Reset()
ConfigurationObject
GlobalState : char
MyM odbusAddress  : Int
MyIPAddress : long
MyPortNumber : Long
NumberAuthorized_IP : int
ListAuthorized_IP : int
NumberForbidden_IP : Int
ListForbidden_IP : long()
NumberConnectionSupported : intTCP management
(from Logical View)Communication application layer
(from Logical View)
------------------------------------------------------------------------------------------------------------------------------------------------
Configuartion layer 
package
Figure 20: MODBUS Configuration layer package 
The Configuration layer package comprises the following classes :  
TConfigureObject: This class groups all data needed for configuring each other 
component. This structure is filled by the method m_Configure from the class 
CoperatingMode . Each class needing to be configured gets its own configuration data 
from this object. The configuration data is implementation dependent therefore the list 
of attributes of this class is provided as an example.  
COperatingMode:  The role of this class is to fill the TConfigureObject  (according to 
the user configuration) and to 
manage the operating modes of the classes described 
below:   
CMODBUSServer
CMODBUSClient
October 24, 2006 http://www.Modbus.org 35/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
CconnexionMngt
5.1.3 Communication layer package 
InterfaceUserApplication
(from Logical View)
ModbusServer
m_ServerReceivingMessage()
m_ServerModbus()
m_BuildResponse()
m_InitServerfunction()ModbusPDU
IsMdbAnalysisOfDataCorrect()
m_BuildModbusException()
m_WritePDU()
Transaction
TransactionId : int
TimeSnapShot : int
IsTransactionTimeOut()
m_WriteTransactionID()
m_StartTimesnapShoot()
InterfaceResponseMsg
(from Logical View)InterfaceIndicationMsg
(from Logical View)ModbusClient
m_ClientReceiv ingResponse()
m_ClientReceiv ingMessage()
m_ClientModbus()--------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------Communication 
Application layer package
Figure 21: MODBUS Communication Application layer package 
The Communication Application layer package comprises the following classes :  
CMODBUSServer : MODBUS query is received from class CInterfaceIndicationMsg 
(by the method m_ServerReceivingMessage). The role of this class is to build the 
MODBUS response or the MODBUS Exceptio n according the query (incoming from 
network). This class implements the Graph St ate of MODBUS server. Response can be 
built only if class COperatingMode has sent both user configuration and right operating 
modes. 
CMODBUSClient : MODBUS query is read from class CInterfaceUserApplication , The 
client task receives query by the 
method m_ClientReceivingMessage. This class 
October 24, 2006 http://www.Modbus.org 36/46Modbus Organization  MODBUS Messaging on TCP/IP Implementation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 37/46implements the State Graph of MODBUS client and manages transactions for linking 
query with response (from network). Query ca n be sent over network only if class 
CoperatingMode has sent both user configuration and right operating modes. 
CTransaction : This class implements methods and structures for managing 
transactions.  
5.1.4 Interface classes 
CInterfaceUserApplication: This class represents the interface with the user 
application, it provides two methods to  access to the user data. In a real 
implementation this method can be implemented in different way depending of the 
hardware and software device capabilities (equivalent to an end-driver, example access to PCMCIA, shared memory, etc). 
CInterfaceIndicationMsg: This Interface class is proposed for 
 sending query from 
Network to the MODBUS Server, and for sendi ng response from Network for the Client. 
This class interfaces TCPManagement and ‘Communication Application Layer’ 
packages (From Network). The implementati on of this class is device dependent. 
 CInterfaceResponseMsg : This Interface class is used for receiving response from the 
Server and for sending query from the client to the Network. This class interfaces 
packages ‘Communication Application Lay er’ and package ‘TCPManagement’ (To 
Network). The implementation of this class is device dependent. 
5.2 IMPLEMENTATION CLASS DIAGRAM 
The following Class Diagram describes the complete diagram of a proposal implementation.  Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 38/46
Figure 22: Class DiagramModbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 39/465.3 SEQUENCE DIAGRAMS 
Two Sequence diagrams are described hereafter are an example in order to illustrate a 
Client MODBUS transaction and a Server MODBUS transaction.  
Figure 23: MODBUS client sequence diagram Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 40/46General comments for a better understanding of the Client  sequence diagram : 
First step : A Reading query comes from User Application (method m_Read).  
Second Step : The ‘Client’ task  receives the MODBUS query  (method 
m_ClientReceivingMessage). This is the entry point of the Client. To associate the 
query with the corresponding response when it will arrive, the Client uses a 
Transaction resource (Class CTransaction ). The MODBUS query is sent to the 
TCP_Management by calling the class interface CInterfaceResponseMsg  (method 
m_MODBUSRequest) 
Third Step:  If the connection is already estab lished there is nothing to do on 
connection, the message can be send over the network. Otherwise, a connection must be opened before the message can be sent over the network. 
At this time the client is waiting for a  response (from a remote serv er)  
Fourth step:  Once a response has been received from the network, the TCP/IP stack 
receives  data (method m_EventOnSocket  is implicitly called). 
 If the connection is already established, th en the MBAP is read for retrieving the 
connection object (connection  object gives memory resource and other information). 
Data coming from network is read and confirmation is sent to the client  task  via the 
class Interface CInterfaceIndicationMsg (method m_MODBUSConfirmation). Client 
task receives the MODBUS Confirmation (method m_ClientReceivingResponse ). 
Finally the  response is  written  to the  user application (method m_WriteData), and 
transaction resource is freed . Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 41/46Hereafter is an example of a MODBUS Server exchange. 
Figure 24: MODBUS server Diagram Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 42/46General comments for a better understanding of the Server sequence diagram : 
First step : a client has sent a query (MOD BUS query) over the network.  
The TCP/IP stack receives data (method m_Ev entOnSocket  is implicitly called).  
Second step : The query  may be a connection request or not (method 
m_IsConnexionRequest). 
If the query is a connection request,  the connection  object and buffers for receiving 
and sending 
the MODBUS frame are allocated (method m_GetObjectConnexion ). 
Just after, the connection access control must be checked and accepted  (method 
m_AcceptConnexion) 
Third step:  If the query is a MODBUS request, the complete MODBUS Query can be 
read (method m_ReceiveData ). At this time the MBAP must be analyzed (method 
m_IsMdbHeaderCorrect ). The complete frame is sent to the Server task  via the 
CinterfaceIndicationMessaging  Class (method m_MODBUSIndication). Server task 
receives the MODBUS Query (method m_ServerReceivingMessage ) and analyses it. 
If an error occur s (function code not supported, etc) , a MODBUSException frame is 
built ( m_BuildMODBUSException), otherwise the response is built. 
Fourth Step:  The response is sent over the network via the 
CinterfaceResponseMessaging (method m_MODBUSResponse). Treatment on the  
connection object  is done by the method m_SendData  (retrieve the connection 
descriptor, etc) and data is  sent over the network. 
5.4 CLASSES AND METHODS DESCRIPTION 
5.4.1 MODBUS Server Class 
Class CMODBUSServer 
class CMODBUSServer   
Stereotype implementationClass 
Provides methods for managing MODBUS Messaging in Server Mode  
Field Summary  
GlobalState  
state of the MODBUS Server protected char
Constructor Summary  
CMODBUSServer (TConfigureObject * lnkConfigureObject)
Constructor : Create internal object  
Method Summary  Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 43/46m_InitServerFunctions (void )
Function called by the constructor for filling array of functions 
'm_ServerFunction' protected void
m_Reset(void )
Method for Resetting Server, return true if reset bool
m_ServerReceivingMessage (TItemConnexion * lnkMODBUS)
Interface with CindicationMsg::m_MOD BUSIndication for receiving Query 
from NetWork return negative value if problem int
m_Start(void )
Method for Starting Server, return true if Started bool
m_Stop(void )
Method for Stopping Server, return true if Stopped bool
m_tServerMODBUS (void )
Server MODBUS task ... protected void
5.4.2 MODBUS Client Class 
Class CMODBUSClient 
class CMODBUSClient   
Provides methods for managing MODBUS Messaging in Client Mode  
Stereotype implementationClass 
Field Summary  
protected 
charGlobalState  
State of the MODBUS Client 
Constructor Summary  
CMODBUSClient (TConfigureObject * lnkConfigureObject)
Constructor : Create internal obj ect , initialize to 0 variables. 
Method Summary  
m_ClientReceivingMessage (TItemConnexion * lnkMODBUS)
Interface provided for receiving message from application Layer Typically : Call CinterfaceUserApplication::m_Read for reading 
data call 
CInterfaceConnexion::m_GetObjectCo nnexion for getting memory for a 
transaction. Return negative value if problem int
m_ClientReceivingResponse (TitemConnexion *
lnkTItemConnexion)  
Interface with Cindic
ationMsg::m_Confirmation for receiving response from 
network return negative value if problem int
m_Reset(void )
Method for Resetting component, return true if reset bool
m_Start(void )
Method for Starting component, return true if started bool
bool m_Stop(void )Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 44/46Method for Stopping component, return true if stopped 
m_tClientMODBUS (void )
Client MODBUS task.... protected void
5.4.3 Interface Classes  
5.4.3.1 Interface Indication class 
Class CInterfaceI ndicationMsg 
Direct Known Subclasses:   
CConnexionMngt
class CInterfaceIndicationMsg 
Class for sending message from TCP_Management  to MODBUS  Server or Client  
Stereotype interface 
Method Summary  
m_MODBUSConfirmation (TItemConnexion * lnkObject)
Method for Receiving incoming Response, calling the Client : could be by 
reference, by Message Queue, Remote procedure Call, ... int
m_MODBUSIndication (TItemConnexion * lnkObject)
Method for reading incoming MODBUS Query and calling the Server : could be by referenc
e, by Message Queue, Remote procedure Call, ... int
5.4.3.2 Interface Response Class 
Class CInterfaceResponseMsg 
Direct Known Subclasses:   
CMODBUSClient , CMODBUSServer
class CInterfaceResponseMsg  
Class for sending response or sending query to TCP_Management from Client or Server  
Stereotype interface 
Method Summary   TitemConnexion 
*m_GetMemoryConnexion (unsigned long IPDest)
Get an object ITemConnexion from memory pool. Return -1 if not enough memory 
int m_MODBUSRequest (TItemConnexion * lnkCMODBUS)
Method for Writing incoming MODBUS Query Client to ConnexionMngt : Modbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 45/46could be by reference, by Message Queue, Remote procedure Call, ... 
m_MODBUSResponse (TItemConnexion * lnkObject)
Method for writing Response from MO DBUS Server to ConnexionMngt 
c
ould be by reference, by Message Queue, Remote procedure Call, ... int
5.4.4 Connexion Management class 
Class CConnexionMngt 
class CConnexionMngt   
Class that manages all TCP Connections 
Stereotype implementationClass 
Field Summary  
protected 
charGlobalState  
Global State of the Component ConnexionMngt 
NbConnectionSupported  
Global number of connections Int
NbLocalConnection  
Number of connections opened by the local Client to a remote  Server Int
NbRemoteConnection  
Number of connections opened by a remote Client to the local  Server Int
Constructor Summary  
CconnexionMngt (TConfigureObject * lnkConfigureObject)
Constructor : Create internal obj ect , initialize to 0 variables. 
Method Summary  
m_EventOnSocket (void )
wake-up int
m_IsConnectionAuthorized (unsigned long IPAddress)
Return true if new connection is authorized bool
m_ReceiveData (TItemConnexion * lnkConnexion)
Interface with CTCPConnexion::write method for reading data from network 
return negative value if problem int
m_Reset(void )
Method for Resetting ConnectionMngt component return true if Reset bool
m_SendData (TItemConnexion * lnkConnexion)
Interface with CTCPConnexion::read method for sending data to the network Return negative value if problem int
m_Start(void )
Method for Starting ConnectionMngt co mponent return true if  Started bool
m_Stop(void )
Method for Stopping component return true if  Stopped boolModbus Organization  MODBUS Messaging on TCP/IP Implem entation Guide V1.0b 
October 24, 2006 http://www.Modbus.org 46/46Modbus Organization  